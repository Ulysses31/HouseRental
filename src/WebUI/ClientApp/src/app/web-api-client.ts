//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAdvertiserInfoClient {
    /**
     * Gets the database AdvertiserInfo with pagination.
     * @param listId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return PaginatedList AdvertiserInfoDto
     */
    getAdvertiserInfoWithPagination(listId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SlApiResponseOfPaginatedListOfAdvertiserInfoDtoAndObject>;
    /**
     * Create a new AdvertiserInfo
     * @param advertiserInfoDto AdvertiserInfoDto
     * @return SlApiResponse AdvertiserInfoDto
     */
    createAdvertiserInfo(advertiserInfoDto: AdvertiserInfoDto): Observable<SlApiResponseOfAdvertiserInfoDtoAndObject>;
    /**
     * Gets the specified AdvertiserInfo.
     * @return PaginatedList AdvertiserInfoDto
     */
    getAdvertiserInfoById(id: number): Observable<SlApiResponseOfAdvertiserInfoDtoAndObject>;
    /**
     * Update the specified AdvertiserInfo
     * @param advertiserInfoDto AdvertiserInfoDto
     * @return SlApiResponse AdvertiserInfoDto
     */
    updateAdvertiserInfo(id: number, advertiserInfoDto: AdvertiserInfoDto): Observable<SlApiResponseOfAdvertiserInfoDtoAndObject>;
    /**
     * Delete the specified AdvertiserInfo
     * @param id int
     * @return SlApiResponse AdvertiserInfoDto
     */
    deleteAdvertiserInfo(id: number): Observable<SlApiResponseOfAdvertiserInfoDtoAndObject>;
    /**
     * Virtualy delete the specified AdvertiserInfo
     * @param id int
     * @return SlApiResponse AdvertiserInfoDto
     */
    disableEnableAdvertiserInfo(id: number): Observable<SlApiResponseOfAdvertiserInfoDtoAndObject>;
}

@Injectable({
    providedIn: 'root'
})
export class AdvertiserInfoClient implements IAdvertiserInfoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Gets the database AdvertiserInfo with pagination.
     * @param listId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return PaginatedList AdvertiserInfoDto
     */
    getAdvertiserInfoWithPagination(listId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SlApiResponseOfPaginatedListOfAdvertiserInfoDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/AdvertiserInfo?";
        if (listId === null)
            throw new Error("The parameter 'listId' cannot be null.");
        else if (listId !== undefined)
            url_ += "ListId=" + encodeURIComponent("" + listId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdvertiserInfoWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdvertiserInfoWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfPaginatedListOfAdvertiserInfoDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfPaginatedListOfAdvertiserInfoDtoAndObject>;
        }));
    }

    protected processGetAdvertiserInfoWithPagination(response: HttpResponseBase): Observable<SlApiResponseOfPaginatedListOfAdvertiserInfoDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("Not Acceptable", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfPaginatedListOfAdvertiserInfoDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Create a new AdvertiserInfo
     * @param advertiserInfoDto AdvertiserInfoDto
     * @return SlApiResponse AdvertiserInfoDto
     */
    createAdvertiserInfo(advertiserInfoDto: AdvertiserInfoDto): Observable<SlApiResponseOfAdvertiserInfoDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/AdvertiserInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(advertiserInfoDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAdvertiserInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAdvertiserInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfAdvertiserInfoDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfAdvertiserInfoDtoAndObject>;
        }));
    }

    protected processCreateAdvertiserInfo(response: HttpResponseBase): Observable<SlApiResponseOfAdvertiserInfoDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfAdvertiserInfoDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Gets the specified AdvertiserInfo.
     * @return PaginatedList AdvertiserInfoDto
     */
    getAdvertiserInfoById(id: number): Observable<SlApiResponseOfAdvertiserInfoDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/AdvertiserInfo/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdvertiserInfoById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdvertiserInfoById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfAdvertiserInfoDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfAdvertiserInfoDtoAndObject>;
        }));
    }

    protected processGetAdvertiserInfoById(response: HttpResponseBase): Observable<SlApiResponseOfAdvertiserInfoDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException(" Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException(" Unauthorized ", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException(" Not Acceptable", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException(" Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfAdvertiserInfoDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException(" Not Found", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Update the specified AdvertiserInfo
     * @param advertiserInfoDto AdvertiserInfoDto
     * @return SlApiResponse AdvertiserInfoDto
     */
    updateAdvertiserInfo(id: number, advertiserInfoDto: AdvertiserInfoDto): Observable<SlApiResponseOfAdvertiserInfoDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/AdvertiserInfo/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(advertiserInfoDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAdvertiserInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAdvertiserInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfAdvertiserInfoDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfAdvertiserInfoDtoAndObject>;
        }));
    }

    protected processUpdateAdvertiserInfo(response: HttpResponseBase): Observable<SlApiResponseOfAdvertiserInfoDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfAdvertiserInfoDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Delete the specified AdvertiserInfo
     * @param id int
     * @return SlApiResponse AdvertiserInfoDto
     */
    deleteAdvertiserInfo(id: number): Observable<SlApiResponseOfAdvertiserInfoDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/AdvertiserInfo/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAdvertiserInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAdvertiserInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfAdvertiserInfoDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfAdvertiserInfoDtoAndObject>;
        }));
    }

    protected processDeleteAdvertiserInfo(response: HttpResponseBase): Observable<SlApiResponseOfAdvertiserInfoDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfAdvertiserInfoDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Virtualy delete the specified AdvertiserInfo
     * @param id int
     * @return SlApiResponse AdvertiserInfoDto
     */
    disableEnableAdvertiserInfo(id: number): Observable<SlApiResponseOfAdvertiserInfoDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/AdvertiserInfo/DisableEnableAdvertiserInfo/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableEnableAdvertiserInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableEnableAdvertiserInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfAdvertiserInfoDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfAdvertiserInfoDtoAndObject>;
        }));
    }

    protected processDisableEnableAdvertiserInfo(response: HttpResponseBase): Observable<SlApiResponseOfAdvertiserInfoDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfAdvertiserInfoDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

export interface IClassifiedCharacteristicsClient {
    /**
     * Gets the database ClassifiedCharacteristics with pagination.
     * @param listId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return PaginatedList ClassifiedCharacteristicsDto
     */
    getClassifiedCharacteristicsWithPagination(listId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SlApiResponseOfPaginatedListOfClassifiedCharacteristicsDtoAndObject>;
    /**
     * Create a new ClassifiedCharacteristics
     * @param classifiedCharacteristicsDto ClassifiedCharacteristicsDto
     * @return SlApiResponse ClassifiedCharacteristicsDto
     */
    createClassifiedCharacteristics(classifiedCharacteristicsDto: ClassifiedCharacteristicsDto): Observable<SlApiResponseOfClassifiedCharacteristicsDtoAndObject>;
    /**
     * Gets the specified ClassifiedCharacteristics.
     * @return PaginatedList ClassifiedCharacteristicsDto
     */
    getClassifiedCharacteristicsById(id: number): Observable<SlApiResponseOfClassifiedCharacteristicsDtoAndObject>;
    /**
     * Update the specified ClassifiedCharacteristics
     * @param classifiedCharacteristicsDto ClassifiedCharacteristicsDto
     * @return SlApiResponse ClassifiedCharacteristicsDto
     */
    updateClassifiedCharacteristics(id: number, classifiedCharacteristicsDto: ClassifiedCharacteristicsDto): Observable<SlApiResponseOfClassifiedCharacteristicsDtoAndObject>;
    /**
     * Delete the specified ClassifiedCharacteristics
     * @param id int
     * @return SlApiResponse ClassifiedCharacteristicsDto
     */
    deleteClassifiedCharacteristics(id: number): Observable<SlApiResponseOfClassifiedCharacteristicsDtoAndObject>;
    /**
     * Virtualy delete the specified ClassifiedCharacteristics
     * @param id int
     * @return SlApiResponse ClassifiedCharacteristicsDto
     */
    disableEnableClassifiedCharacteristics(id: number): Observable<SlApiResponseOfClassifiedCharacteristicsDtoAndObject>;
}

@Injectable({
    providedIn: 'root'
})
export class ClassifiedCharacteristicsClient implements IClassifiedCharacteristicsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Gets the database ClassifiedCharacteristics with pagination.
     * @param listId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return PaginatedList ClassifiedCharacteristicsDto
     */
    getClassifiedCharacteristicsWithPagination(listId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SlApiResponseOfPaginatedListOfClassifiedCharacteristicsDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/ClassifiedCharacteristics?";
        if (listId === null)
            throw new Error("The parameter 'listId' cannot be null.");
        else if (listId !== undefined)
            url_ += "ListId=" + encodeURIComponent("" + listId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClassifiedCharacteristicsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClassifiedCharacteristicsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfPaginatedListOfClassifiedCharacteristicsDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfPaginatedListOfClassifiedCharacteristicsDtoAndObject>;
        }));
    }

    protected processGetClassifiedCharacteristicsWithPagination(response: HttpResponseBase): Observable<SlApiResponseOfPaginatedListOfClassifiedCharacteristicsDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("Not Acceptable", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfPaginatedListOfClassifiedCharacteristicsDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Create a new ClassifiedCharacteristics
     * @param classifiedCharacteristicsDto ClassifiedCharacteristicsDto
     * @return SlApiResponse ClassifiedCharacteristicsDto
     */
    createClassifiedCharacteristics(classifiedCharacteristicsDto: ClassifiedCharacteristicsDto): Observable<SlApiResponseOfClassifiedCharacteristicsDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/ClassifiedCharacteristics";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(classifiedCharacteristicsDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateClassifiedCharacteristics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateClassifiedCharacteristics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfClassifiedCharacteristicsDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfClassifiedCharacteristicsDtoAndObject>;
        }));
    }

    protected processCreateClassifiedCharacteristics(response: HttpResponseBase): Observable<SlApiResponseOfClassifiedCharacteristicsDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfClassifiedCharacteristicsDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Gets the specified ClassifiedCharacteristics.
     * @return PaginatedList ClassifiedCharacteristicsDto
     */
    getClassifiedCharacteristicsById(id: number): Observable<SlApiResponseOfClassifiedCharacteristicsDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/ClassifiedCharacteristics/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClassifiedCharacteristicsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClassifiedCharacteristicsById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfClassifiedCharacteristicsDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfClassifiedCharacteristicsDtoAndObject>;
        }));
    }

    protected processGetClassifiedCharacteristicsById(response: HttpResponseBase): Observable<SlApiResponseOfClassifiedCharacteristicsDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException(" Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException(" Unauthorized ", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException(" Not Acceptable", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException(" Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfClassifiedCharacteristicsDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException(" Not Found", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Update the specified ClassifiedCharacteristics
     * @param classifiedCharacteristicsDto ClassifiedCharacteristicsDto
     * @return SlApiResponse ClassifiedCharacteristicsDto
     */
    updateClassifiedCharacteristics(id: number, classifiedCharacteristicsDto: ClassifiedCharacteristicsDto): Observable<SlApiResponseOfClassifiedCharacteristicsDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/ClassifiedCharacteristics/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(classifiedCharacteristicsDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateClassifiedCharacteristics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateClassifiedCharacteristics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfClassifiedCharacteristicsDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfClassifiedCharacteristicsDtoAndObject>;
        }));
    }

    protected processUpdateClassifiedCharacteristics(response: HttpResponseBase): Observable<SlApiResponseOfClassifiedCharacteristicsDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfClassifiedCharacteristicsDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Delete the specified ClassifiedCharacteristics
     * @param id int
     * @return SlApiResponse ClassifiedCharacteristicsDto
     */
    deleteClassifiedCharacteristics(id: number): Observable<SlApiResponseOfClassifiedCharacteristicsDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/ClassifiedCharacteristics/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteClassifiedCharacteristics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteClassifiedCharacteristics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfClassifiedCharacteristicsDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfClassifiedCharacteristicsDtoAndObject>;
        }));
    }

    protected processDeleteClassifiedCharacteristics(response: HttpResponseBase): Observable<SlApiResponseOfClassifiedCharacteristicsDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfClassifiedCharacteristicsDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Virtualy delete the specified ClassifiedCharacteristics
     * @param id int
     * @return SlApiResponse ClassifiedCharacteristicsDto
     */
    disableEnableClassifiedCharacteristics(id: number): Observable<SlApiResponseOfClassifiedCharacteristicsDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/ClassifiedCharacteristics/DisableEnableClassifiedCharacteristics/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableEnableClassifiedCharacteristics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableEnableClassifiedCharacteristics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfClassifiedCharacteristicsDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfClassifiedCharacteristicsDtoAndObject>;
        }));
    }

    protected processDisableEnableClassifiedCharacteristics(response: HttpResponseBase): Observable<SlApiResponseOfClassifiedCharacteristicsDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfClassifiedCharacteristicsDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

export interface IClassifiedConstructionClient {
    /**
     * Gets the database ClassifiedConstruction with pagination.
     * @param listId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return PaginatedList ClassifiedConstructionDto
     */
    getClassifiedConstructionWithPagination(listId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SlApiResponseOfPaginatedListOfClassifiedConstructionDtoAndObject>;
    /**
     * Create a new ClassifiedConstruction
     * @param classifiedConstructionDto ClassifiedConstructionDto
     * @return SlApiResponse ClassifiedConstructionDto
     */
    createClassifiedConstruction(classifiedConstructionDto: ClassifiedConstructionDto): Observable<SlApiResponseOfClassifiedConstructionDtoAndObject>;
    /**
     * Gets the specified ClassifiedConstruction.
     * @return PaginatedList ClassifiedConstructionDto
     */
    getClassifiedConstructionById(id: number): Observable<SlApiResponseOfClassifiedConstructionDtoAndObject>;
    /**
     * Update the specified ClassifiedConstruction
     * @param classifiedConstructionDto ClassifiedConstructionDto
     * @return SlApiResponse ClassifiedConstructionDto
     */
    updateClassifiedConstruction(id: number, classifiedConstructionDto: ClassifiedConstructionDto): Observable<SlApiResponseOfClassifiedConstructionDtoAndObject>;
    /**
     * Delete the specified ClassifiedConstruction
     * @param id int
     * @return SlApiResponse ClassifiedConstructionDto
     */
    deleteClassifiedConstruction(id: number): Observable<SlApiResponseOfClassifiedConstructionDtoAndObject>;
    /**
     * Virtualy delete the specified ClassifiedConstruction
     * @param id int
     * @return SlApiResponse ClassifiedConstructionDto
     */
    disableEnableClassifiedConstruction(id: number): Observable<SlApiResponseOfClassifiedConstructionDtoAndObject>;
}

@Injectable({
    providedIn: 'root'
})
export class ClassifiedConstructionClient implements IClassifiedConstructionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Gets the database ClassifiedConstruction with pagination.
     * @param listId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return PaginatedList ClassifiedConstructionDto
     */
    getClassifiedConstructionWithPagination(listId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SlApiResponseOfPaginatedListOfClassifiedConstructionDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/ClassifiedConstruction?";
        if (listId === null)
            throw new Error("The parameter 'listId' cannot be null.");
        else if (listId !== undefined)
            url_ += "ListId=" + encodeURIComponent("" + listId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClassifiedConstructionWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClassifiedConstructionWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfPaginatedListOfClassifiedConstructionDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfPaginatedListOfClassifiedConstructionDtoAndObject>;
        }));
    }

    protected processGetClassifiedConstructionWithPagination(response: HttpResponseBase): Observable<SlApiResponseOfPaginatedListOfClassifiedConstructionDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("Not Acceptable", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfPaginatedListOfClassifiedConstructionDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Create a new ClassifiedConstruction
     * @param classifiedConstructionDto ClassifiedConstructionDto
     * @return SlApiResponse ClassifiedConstructionDto
     */
    createClassifiedConstruction(classifiedConstructionDto: ClassifiedConstructionDto): Observable<SlApiResponseOfClassifiedConstructionDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/ClassifiedConstruction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(classifiedConstructionDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateClassifiedConstruction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateClassifiedConstruction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfClassifiedConstructionDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfClassifiedConstructionDtoAndObject>;
        }));
    }

    protected processCreateClassifiedConstruction(response: HttpResponseBase): Observable<SlApiResponseOfClassifiedConstructionDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfClassifiedConstructionDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Gets the specified ClassifiedConstruction.
     * @return PaginatedList ClassifiedConstructionDto
     */
    getClassifiedConstructionById(id: number): Observable<SlApiResponseOfClassifiedConstructionDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/ClassifiedConstruction/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClassifiedConstructionById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClassifiedConstructionById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfClassifiedConstructionDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfClassifiedConstructionDtoAndObject>;
        }));
    }

    protected processGetClassifiedConstructionById(response: HttpResponseBase): Observable<SlApiResponseOfClassifiedConstructionDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException(" Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException(" Unauthorized ", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException(" Not Acceptable", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException(" Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfClassifiedConstructionDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException(" Not Found", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Update the specified ClassifiedConstruction
     * @param classifiedConstructionDto ClassifiedConstructionDto
     * @return SlApiResponse ClassifiedConstructionDto
     */
    updateClassifiedConstruction(id: number, classifiedConstructionDto: ClassifiedConstructionDto): Observable<SlApiResponseOfClassifiedConstructionDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/ClassifiedConstruction/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(classifiedConstructionDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateClassifiedConstruction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateClassifiedConstruction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfClassifiedConstructionDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfClassifiedConstructionDtoAndObject>;
        }));
    }

    protected processUpdateClassifiedConstruction(response: HttpResponseBase): Observable<SlApiResponseOfClassifiedConstructionDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfClassifiedConstructionDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Delete the specified ClassifiedConstruction
     * @param id int
     * @return SlApiResponse ClassifiedConstructionDto
     */
    deleteClassifiedConstruction(id: number): Observable<SlApiResponseOfClassifiedConstructionDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/ClassifiedConstruction/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteClassifiedConstruction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteClassifiedConstruction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfClassifiedConstructionDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfClassifiedConstructionDtoAndObject>;
        }));
    }

    protected processDeleteClassifiedConstruction(response: HttpResponseBase): Observable<SlApiResponseOfClassifiedConstructionDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfClassifiedConstructionDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Virtualy delete the specified ClassifiedConstruction
     * @param id int
     * @return SlApiResponse ClassifiedConstructionDto
     */
    disableEnableClassifiedConstruction(id: number): Observable<SlApiResponseOfClassifiedConstructionDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/ClassifiedConstruction/DisableEnableClassifiedConstruction/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableEnableClassifiedConstruction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableEnableClassifiedConstruction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfClassifiedConstructionDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfClassifiedConstructionDtoAndObject>;
        }));
    }

    protected processDisableEnableClassifiedConstruction(response: HttpResponseBase): Observable<SlApiResponseOfClassifiedConstructionDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfClassifiedConstructionDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

export interface IClassifiedPurposeClient {
    /**
     * Gets the database ClassifiedPurpose with pagination.
     * @param listId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return PaginatedList ClassifiedPurposeDto
     */
    getClassifiedPurposeWithPagination(listId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SlApiResponseOfPaginatedListOfClassifiedPurposeDtoAndObject>;
    /**
     * Create a new ClassifiedPurpose
     * @param classifiedPurposeDto ClassifiedPurposeDto
     * @return SlApiResponse ClassifiedPurposeDto
     */
    createClassifiedPurpose(classifiedPurposeDto: ClassifiedPurposeDto): Observable<SlApiResponseOfClassifiedPurposeDtoAndObject>;
    /**
     * Gets the specified ClassifiedPurpose.
     * @return PaginatedList ClassifiedPurposeDto
     */
    getClassifiedPurposeById(id: number): Observable<SlApiResponseOfClassifiedPurposeDtoAndObject>;
    /**
     * Update the specified ClassifiedPurpose
     * @param classifiedPurposeDto ClassifiedPurposeDto
     * @return SlApiResponse ClassifiedPurposeDto
     */
    updateClassifiedPurpose(id: number, classifiedPurposeDto: ClassifiedPurposeDto): Observable<SlApiResponseOfClassifiedPurposeDtoAndObject>;
    /**
     * Delete the specified ClassifiedPurpose
     * @param id int
     * @return SlApiResponse ClassifiedPurposeDto
     */
    deleteClassifiedPurpose(id: number): Observable<SlApiResponseOfClassifiedPurposeDtoAndObject>;
    /**
     * Virtualy delete the specified ClassifiedPurpose
     * @param id int
     * @return SlApiResponse ClassifiedPurposeDto
     */
    disableEnableClassifiedPurpose(id: number): Observable<SlApiResponseOfClassifiedPurposeDtoAndObject>;
}

@Injectable({
    providedIn: 'root'
})
export class ClassifiedPurposeClient implements IClassifiedPurposeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Gets the database ClassifiedPurpose with pagination.
     * @param listId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return PaginatedList ClassifiedPurposeDto
     */
    getClassifiedPurposeWithPagination(listId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SlApiResponseOfPaginatedListOfClassifiedPurposeDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/ClassifiedPurpose?";
        if (listId === null)
            throw new Error("The parameter 'listId' cannot be null.");
        else if (listId !== undefined)
            url_ += "ListId=" + encodeURIComponent("" + listId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClassifiedPurposeWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClassifiedPurposeWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfPaginatedListOfClassifiedPurposeDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfPaginatedListOfClassifiedPurposeDtoAndObject>;
        }));
    }

    protected processGetClassifiedPurposeWithPagination(response: HttpResponseBase): Observable<SlApiResponseOfPaginatedListOfClassifiedPurposeDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("Not Acceptable", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfPaginatedListOfClassifiedPurposeDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Create a new ClassifiedPurpose
     * @param classifiedPurposeDto ClassifiedPurposeDto
     * @return SlApiResponse ClassifiedPurposeDto
     */
    createClassifiedPurpose(classifiedPurposeDto: ClassifiedPurposeDto): Observable<SlApiResponseOfClassifiedPurposeDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/ClassifiedPurpose";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(classifiedPurposeDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateClassifiedPurpose(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateClassifiedPurpose(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfClassifiedPurposeDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfClassifiedPurposeDtoAndObject>;
        }));
    }

    protected processCreateClassifiedPurpose(response: HttpResponseBase): Observable<SlApiResponseOfClassifiedPurposeDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfClassifiedPurposeDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Gets the specified ClassifiedPurpose.
     * @return PaginatedList ClassifiedPurposeDto
     */
    getClassifiedPurposeById(id: number): Observable<SlApiResponseOfClassifiedPurposeDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/ClassifiedPurpose/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClassifiedPurposeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClassifiedPurposeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfClassifiedPurposeDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfClassifiedPurposeDtoAndObject>;
        }));
    }

    protected processGetClassifiedPurposeById(response: HttpResponseBase): Observable<SlApiResponseOfClassifiedPurposeDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException(" Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException(" Unauthorized ", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException(" Not Acceptable", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException(" Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfClassifiedPurposeDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException(" Not Found", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Update the specified ClassifiedPurpose
     * @param classifiedPurposeDto ClassifiedPurposeDto
     * @return SlApiResponse ClassifiedPurposeDto
     */
    updateClassifiedPurpose(id: number, classifiedPurposeDto: ClassifiedPurposeDto): Observable<SlApiResponseOfClassifiedPurposeDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/ClassifiedPurpose/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(classifiedPurposeDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateClassifiedPurpose(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateClassifiedPurpose(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfClassifiedPurposeDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfClassifiedPurposeDtoAndObject>;
        }));
    }

    protected processUpdateClassifiedPurpose(response: HttpResponseBase): Observable<SlApiResponseOfClassifiedPurposeDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfClassifiedPurposeDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Delete the specified ClassifiedPurpose
     * @param id int
     * @return SlApiResponse ClassifiedPurposeDto
     */
    deleteClassifiedPurpose(id: number): Observable<SlApiResponseOfClassifiedPurposeDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/ClassifiedPurpose/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteClassifiedPurpose(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteClassifiedPurpose(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfClassifiedPurposeDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfClassifiedPurposeDtoAndObject>;
        }));
    }

    protected processDeleteClassifiedPurpose(response: HttpResponseBase): Observable<SlApiResponseOfClassifiedPurposeDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfClassifiedPurposeDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Virtualy delete the specified ClassifiedPurpose
     * @param id int
     * @return SlApiResponse ClassifiedPurposeDto
     */
    disableEnableClassifiedPurpose(id: number): Observable<SlApiResponseOfClassifiedPurposeDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/ClassifiedPurpose/DisableEnableClassifiedPurpose/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableEnableClassifiedPurpose(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableEnableClassifiedPurpose(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfClassifiedPurposeDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfClassifiedPurposeDtoAndObject>;
        }));
    }

    protected processDisableEnableClassifiedPurpose(response: HttpResponseBase): Observable<SlApiResponseOfClassifiedPurposeDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfClassifiedPurposeDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

export interface IClassifiedTypeClient {
    /**
     * Gets the database ClassifiedType with pagination.
     * @param listId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return PaginatedList ClassifiedTypeDto
     */
    getClassifiedTypeWithPagination(listId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SlApiResponseOfPaginatedListOfClassifiedTypeDtoAndObject>;
    /**
     * Create a new ClassifiedType
     * @param classifiedTypeDto ClassifiedTypeDto
     * @return SlApiResponse ClassifiedTypeDto
     */
    createClassifiedType(classifiedTypeDto: ClassifiedTypeDto): Observable<SlApiResponseOfClassifiedTypeDtoAndObject>;
    /**
     * Gets the specified ClassifiedType.
     * @return PaginatedList ClassifiedTypeDto
     */
    getClassifiedTypeById(id: number): Observable<SlApiResponseOfClassifiedTypeDtoAndObject>;
    /**
     * Update the specified ClassifiedType
     * @param classifiedTypeDto ClassifiedTypeDto
     * @return SlApiResponse ClassifiedTypeDto
     */
    updateClassifiedType(id: number, classifiedTypeDto: ClassifiedTypeDto): Observable<SlApiResponseOfClassifiedTypeDtoAndObject>;
    /**
     * Delete the specified ClassifiedType
     * @param id int
     * @return SlApiResponse ClassifiedTypeDto
     */
    deleteClassifiedType(id: number): Observable<SlApiResponseOfClassifiedTypeDtoAndObject>;
    /**
     * Virtualy delete the specified ClassifiedType
     * @param id int
     * @return SlApiResponse ClassifiedTypeDto
     */
    disableEnableClassifiedType(id: number): Observable<SlApiResponseOfClassifiedTypeDtoAndObject>;
}

@Injectable({
    providedIn: 'root'
})
export class ClassifiedTypeClient implements IClassifiedTypeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Gets the database ClassifiedType with pagination.
     * @param listId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return PaginatedList ClassifiedTypeDto
     */
    getClassifiedTypeWithPagination(listId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SlApiResponseOfPaginatedListOfClassifiedTypeDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/ClassifiedType?";
        if (listId === null)
            throw new Error("The parameter 'listId' cannot be null.");
        else if (listId !== undefined)
            url_ += "ListId=" + encodeURIComponent("" + listId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClassifiedTypeWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClassifiedTypeWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfPaginatedListOfClassifiedTypeDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfPaginatedListOfClassifiedTypeDtoAndObject>;
        }));
    }

    protected processGetClassifiedTypeWithPagination(response: HttpResponseBase): Observable<SlApiResponseOfPaginatedListOfClassifiedTypeDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("Not Acceptable", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfPaginatedListOfClassifiedTypeDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Create a new ClassifiedType
     * @param classifiedTypeDto ClassifiedTypeDto
     * @return SlApiResponse ClassifiedTypeDto
     */
    createClassifiedType(classifiedTypeDto: ClassifiedTypeDto): Observable<SlApiResponseOfClassifiedTypeDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/ClassifiedType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(classifiedTypeDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateClassifiedType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateClassifiedType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfClassifiedTypeDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfClassifiedTypeDtoAndObject>;
        }));
    }

    protected processCreateClassifiedType(response: HttpResponseBase): Observable<SlApiResponseOfClassifiedTypeDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfClassifiedTypeDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Gets the specified ClassifiedType.
     * @return PaginatedList ClassifiedTypeDto
     */
    getClassifiedTypeById(id: number): Observable<SlApiResponseOfClassifiedTypeDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/ClassifiedType/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClassifiedTypeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClassifiedTypeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfClassifiedTypeDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfClassifiedTypeDtoAndObject>;
        }));
    }

    protected processGetClassifiedTypeById(response: HttpResponseBase): Observable<SlApiResponseOfClassifiedTypeDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException(" Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException(" Unauthorized ", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException(" Not Acceptable", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException(" Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfClassifiedTypeDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException(" Not Found", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Update the specified ClassifiedType
     * @param classifiedTypeDto ClassifiedTypeDto
     * @return SlApiResponse ClassifiedTypeDto
     */
    updateClassifiedType(id: number, classifiedTypeDto: ClassifiedTypeDto): Observable<SlApiResponseOfClassifiedTypeDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/ClassifiedType/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(classifiedTypeDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateClassifiedType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateClassifiedType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfClassifiedTypeDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfClassifiedTypeDtoAndObject>;
        }));
    }

    protected processUpdateClassifiedType(response: HttpResponseBase): Observable<SlApiResponseOfClassifiedTypeDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfClassifiedTypeDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Delete the specified ClassifiedType
     * @param id int
     * @return SlApiResponse ClassifiedTypeDto
     */
    deleteClassifiedType(id: number): Observable<SlApiResponseOfClassifiedTypeDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/ClassifiedType/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteClassifiedType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteClassifiedType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfClassifiedTypeDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfClassifiedTypeDtoAndObject>;
        }));
    }

    protected processDeleteClassifiedType(response: HttpResponseBase): Observable<SlApiResponseOfClassifiedTypeDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfClassifiedTypeDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Virtualy delete the specified ClassifiedType
     * @param id int
     * @return SlApiResponse ClassifiedTypeDto
     */
    disableEnableClassifiedType(id: number): Observable<SlApiResponseOfClassifiedTypeDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/ClassifiedType/DisableEnableClassifiedType/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableEnableClassifiedType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableEnableClassifiedType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfClassifiedTypeDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfClassifiedTypeDtoAndObject>;
        }));
    }

    protected processDisableEnableClassifiedType(response: HttpResponseBase): Observable<SlApiResponseOfClassifiedTypeDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfClassifiedTypeDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

export interface IEnergyClassClient {
    /**
     * Gets the database EnergyClass with pagination.
     * @param listId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return PaginatedList EnergyClassDto
     */
    getEnergyClassWithPagination(listId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SlApiResponseOfPaginatedListOfEnergyClassDtoAndObject>;
    /**
     * Create a new EnergyClass
     * @param energyClassDto EnergyClassDto
     * @return SlApiResponse EnergyClassDto
     */
    createEnergyClass(energyClassDto: EnergyClassDto): Observable<SlApiResponseOfEnergyClassDtoAndObject>;
    /**
     * Gets the specified EnergyClass.
     * @return PaginatedList EnergyClassDto
     */
    getEnergyClassById(id: number): Observable<SlApiResponseOfEnergyClassDtoAndObject>;
    /**
     * Update the specified EnergyClass
     * @param energyClassDto EnergyClassDto
     * @return SlApiResponse EnergyClassDto
     */
    updateEnergyClass(id: number, energyClassDto: EnergyClassDto): Observable<SlApiResponseOfEnergyClassDtoAndObject>;
    /**
     * Delete the specified EnergyClass
     * @param id int
     * @return SlApiResponse EnergyClassDto
     */
    deleteEnergyClass(id: number): Observable<SlApiResponseOfEnergyClassDtoAndObject>;
    /**
     * Virtualy delete the specified EnergyClass
     * @param id int
     * @return SlApiResponse EnergyClassDto
     */
    disableEnableEnergyClass(id: number): Observable<SlApiResponseOfEnergyClassDtoAndObject>;
}

@Injectable({
    providedIn: 'root'
})
export class EnergyClassClient implements IEnergyClassClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Gets the database EnergyClass with pagination.
     * @param listId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return PaginatedList EnergyClassDto
     */
    getEnergyClassWithPagination(listId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SlApiResponseOfPaginatedListOfEnergyClassDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/EnergyClass?";
        if (listId === null)
            throw new Error("The parameter 'listId' cannot be null.");
        else if (listId !== undefined)
            url_ += "ListId=" + encodeURIComponent("" + listId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnergyClassWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnergyClassWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfPaginatedListOfEnergyClassDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfPaginatedListOfEnergyClassDtoAndObject>;
        }));
    }

    protected processGetEnergyClassWithPagination(response: HttpResponseBase): Observable<SlApiResponseOfPaginatedListOfEnergyClassDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("Not Acceptable", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfPaginatedListOfEnergyClassDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Create a new EnergyClass
     * @param energyClassDto EnergyClassDto
     * @return SlApiResponse EnergyClassDto
     */
    createEnergyClass(energyClassDto: EnergyClassDto): Observable<SlApiResponseOfEnergyClassDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/EnergyClass";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(energyClassDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEnergyClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEnergyClass(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfEnergyClassDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfEnergyClassDtoAndObject>;
        }));
    }

    protected processCreateEnergyClass(response: HttpResponseBase): Observable<SlApiResponseOfEnergyClassDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfEnergyClassDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Gets the specified EnergyClass.
     * @return PaginatedList EnergyClassDto
     */
    getEnergyClassById(id: number): Observable<SlApiResponseOfEnergyClassDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/EnergyClass/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnergyClassById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnergyClassById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfEnergyClassDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfEnergyClassDtoAndObject>;
        }));
    }

    protected processGetEnergyClassById(response: HttpResponseBase): Observable<SlApiResponseOfEnergyClassDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException(" Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException(" Unauthorized ", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException(" Not Acceptable", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException(" Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfEnergyClassDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException(" Not Found", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Update the specified EnergyClass
     * @param energyClassDto EnergyClassDto
     * @return SlApiResponse EnergyClassDto
     */
    updateEnergyClass(id: number, energyClassDto: EnergyClassDto): Observable<SlApiResponseOfEnergyClassDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/EnergyClass/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(energyClassDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEnergyClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEnergyClass(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfEnergyClassDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfEnergyClassDtoAndObject>;
        }));
    }

    protected processUpdateEnergyClass(response: HttpResponseBase): Observable<SlApiResponseOfEnergyClassDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfEnergyClassDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Delete the specified EnergyClass
     * @param id int
     * @return SlApiResponse EnergyClassDto
     */
    deleteEnergyClass(id: number): Observable<SlApiResponseOfEnergyClassDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/EnergyClass/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEnergyClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEnergyClass(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfEnergyClassDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfEnergyClassDtoAndObject>;
        }));
    }

    protected processDeleteEnergyClass(response: HttpResponseBase): Observable<SlApiResponseOfEnergyClassDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfEnergyClassDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Virtualy delete the specified EnergyClass
     * @param id int
     * @return SlApiResponse EnergyClassDto
     */
    disableEnableEnergyClass(id: number): Observable<SlApiResponseOfEnergyClassDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/EnergyClass/DisableEnableEnergyClass/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableEnableEnergyClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableEnableEnergyClass(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfEnergyClassDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfEnergyClassDtoAndObject>;
        }));
    }

    protected processDisableEnableEnergyClass(response: HttpResponseBase): Observable<SlApiResponseOfEnergyClassDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfEnergyClassDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

export interface IExteriorFeatureClient {
    /**
     * Gets the database ExteriorFeature with pagination.
     * @param listId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return PaginatedList ExteriorFeatureDto
     */
    getExteriorFeatureWithPagination(listId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SlApiResponseOfPaginatedListOfExteriorFeatureDtoAndObject>;
    /**
     * Create a new ExteriorFeature
     * @param exteriorFeatureDto ExteriorFeatureDto
     * @return SlApiResponse ExteriorFeatureDto
     */
    createExteriorFeature(exteriorFeatureDto: ExteriorFeatureDto): Observable<SlApiResponseOfExteriorFeatureDtoAndObject>;
    /**
     * Gets the specified ExteriorFeature.
     * @return PaginatedList ExteriorFeatureDto
     */
    getExteriorFeatureById(id: number): Observable<SlApiResponseOfExteriorFeatureDtoAndObject>;
    /**
     * Update the specified ExteriorFeature
     * @param exteriorFeatureDto ExteriorFeatureDto
     * @return SlApiResponse ExteriorFeatureDto
     */
    updateExteriorFeature(id: number, exteriorFeatureDto: ExteriorFeatureDto): Observable<SlApiResponseOfExteriorFeatureDtoAndObject>;
    /**
     * Delete the specified ExteriorFeature
     * @param id int
     * @return SlApiResponse ExteriorFeatureDto
     */
    deleteExteriorFeature(id: number): Observable<SlApiResponseOfExteriorFeatureDtoAndObject>;
    /**
     * Virtualy delete the specified ExteriorFeature
     * @param id int
     * @return SlApiResponse ExteriorFeatureDto
     */
    disableEnableExteriorFeature(id: number): Observable<SlApiResponseOfExteriorFeatureDtoAndObject>;
}

@Injectable({
    providedIn: 'root'
})
export class ExteriorFeatureClient implements IExteriorFeatureClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Gets the database ExteriorFeature with pagination.
     * @param listId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return PaginatedList ExteriorFeatureDto
     */
    getExteriorFeatureWithPagination(listId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SlApiResponseOfPaginatedListOfExteriorFeatureDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/ExteriorFeature?";
        if (listId === null)
            throw new Error("The parameter 'listId' cannot be null.");
        else if (listId !== undefined)
            url_ += "ListId=" + encodeURIComponent("" + listId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExteriorFeatureWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExteriorFeatureWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfPaginatedListOfExteriorFeatureDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfPaginatedListOfExteriorFeatureDtoAndObject>;
        }));
    }

    protected processGetExteriorFeatureWithPagination(response: HttpResponseBase): Observable<SlApiResponseOfPaginatedListOfExteriorFeatureDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("Not Acceptable", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfPaginatedListOfExteriorFeatureDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Create a new ExteriorFeature
     * @param exteriorFeatureDto ExteriorFeatureDto
     * @return SlApiResponse ExteriorFeatureDto
     */
    createExteriorFeature(exteriorFeatureDto: ExteriorFeatureDto): Observable<SlApiResponseOfExteriorFeatureDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/ExteriorFeature";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(exteriorFeatureDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateExteriorFeature(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateExteriorFeature(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfExteriorFeatureDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfExteriorFeatureDtoAndObject>;
        }));
    }

    protected processCreateExteriorFeature(response: HttpResponseBase): Observable<SlApiResponseOfExteriorFeatureDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfExteriorFeatureDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Gets the specified ExteriorFeature.
     * @return PaginatedList ExteriorFeatureDto
     */
    getExteriorFeatureById(id: number): Observable<SlApiResponseOfExteriorFeatureDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/ExteriorFeature/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExteriorFeatureById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExteriorFeatureById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfExteriorFeatureDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfExteriorFeatureDtoAndObject>;
        }));
    }

    protected processGetExteriorFeatureById(response: HttpResponseBase): Observable<SlApiResponseOfExteriorFeatureDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException(" Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException(" Unauthorized ", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException(" Not Acceptable", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException(" Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfExteriorFeatureDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException(" Not Found", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Update the specified ExteriorFeature
     * @param exteriorFeatureDto ExteriorFeatureDto
     * @return SlApiResponse ExteriorFeatureDto
     */
    updateExteriorFeature(id: number, exteriorFeatureDto: ExteriorFeatureDto): Observable<SlApiResponseOfExteriorFeatureDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/ExteriorFeature/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(exteriorFeatureDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateExteriorFeature(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateExteriorFeature(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfExteriorFeatureDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfExteriorFeatureDtoAndObject>;
        }));
    }

    protected processUpdateExteriorFeature(response: HttpResponseBase): Observable<SlApiResponseOfExteriorFeatureDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfExteriorFeatureDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Delete the specified ExteriorFeature
     * @param id int
     * @return SlApiResponse ExteriorFeatureDto
     */
    deleteExteriorFeature(id: number): Observable<SlApiResponseOfExteriorFeatureDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/ExteriorFeature/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteExteriorFeature(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteExteriorFeature(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfExteriorFeatureDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfExteriorFeatureDtoAndObject>;
        }));
    }

    protected processDeleteExteriorFeature(response: HttpResponseBase): Observable<SlApiResponseOfExteriorFeatureDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfExteriorFeatureDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Virtualy delete the specified ExteriorFeature
     * @param id int
     * @return SlApiResponse ExteriorFeatureDto
     */
    disableEnableExteriorFeature(id: number): Observable<SlApiResponseOfExteriorFeatureDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/ExteriorFeature/DisableEnableExteriorFeature/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableEnableExteriorFeature(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableEnableExteriorFeature(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfExteriorFeatureDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfExteriorFeatureDtoAndObject>;
        }));
    }

    protected processDisableEnableExteriorFeature(response: HttpResponseBase): Observable<SlApiResponseOfExteriorFeatureDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfExteriorFeatureDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

export interface IFloorNoClient {
    /**
     * Gets the database FloorNo with pagination.
     * @param listId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return PaginatedList FloorNoDto
     */
    getFloorNoWithPagination(listId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SlApiResponseOfPaginatedListOfFloorNoDtoAndObject>;
    /**
     * Create a new FloorNo
     * @param floorNoDto FloorNoDto
     * @return SlApiResponse FloorNoDto
     */
    createFloorNo(floorNoDto: FloorNoDto): Observable<SlApiResponseOfFloorNoDtoAndObject>;
    /**
     * Gets the specified FloorNo.
     * @return PaginatedList FloorNoDto
     */
    getFloorNoById(id: number): Observable<SlApiResponseOfFloorNoDtoAndObject>;
    /**
     * Update the specified FloorNo
     * @param floorNoDto FloorNoDto
     * @return SlApiResponse FloorNoDto
     */
    updateFloorNo(id: number, floorNoDto: FloorNoDto): Observable<SlApiResponseOfFloorNoDtoAndObject>;
    /**
     * Delete the specified FloorNo
     * @param id int
     * @return SlApiResponse FloorNoDto
     */
    deleteFloorNo(id: number): Observable<SlApiResponseOfFloorNoDtoAndObject>;
    /**
     * Virtualy delete the specified FloorNo
     * @param id int
     * @return SlApiResponse FloorNoDto
     */
    disableEnableFloorNo(id: number): Observable<SlApiResponseOfFloorNoDtoAndObject>;
}

@Injectable({
    providedIn: 'root'
})
export class FloorNoClient implements IFloorNoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Gets the database FloorNo with pagination.
     * @param listId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return PaginatedList FloorNoDto
     */
    getFloorNoWithPagination(listId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SlApiResponseOfPaginatedListOfFloorNoDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/FloorNo?";
        if (listId === null)
            throw new Error("The parameter 'listId' cannot be null.");
        else if (listId !== undefined)
            url_ += "ListId=" + encodeURIComponent("" + listId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFloorNoWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFloorNoWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfPaginatedListOfFloorNoDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfPaginatedListOfFloorNoDtoAndObject>;
        }));
    }

    protected processGetFloorNoWithPagination(response: HttpResponseBase): Observable<SlApiResponseOfPaginatedListOfFloorNoDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("Not Acceptable", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfPaginatedListOfFloorNoDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Create a new FloorNo
     * @param floorNoDto FloorNoDto
     * @return SlApiResponse FloorNoDto
     */
    createFloorNo(floorNoDto: FloorNoDto): Observable<SlApiResponseOfFloorNoDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/FloorNo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(floorNoDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFloorNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFloorNo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfFloorNoDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfFloorNoDtoAndObject>;
        }));
    }

    protected processCreateFloorNo(response: HttpResponseBase): Observable<SlApiResponseOfFloorNoDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfFloorNoDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Gets the specified FloorNo.
     * @return PaginatedList FloorNoDto
     */
    getFloorNoById(id: number): Observable<SlApiResponseOfFloorNoDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/FloorNo/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFloorNoById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFloorNoById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfFloorNoDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfFloorNoDtoAndObject>;
        }));
    }

    protected processGetFloorNoById(response: HttpResponseBase): Observable<SlApiResponseOfFloorNoDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException(" Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException(" Unauthorized ", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException(" Not Acceptable", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException(" Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfFloorNoDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException(" Not Found", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Update the specified FloorNo
     * @param floorNoDto FloorNoDto
     * @return SlApiResponse FloorNoDto
     */
    updateFloorNo(id: number, floorNoDto: FloorNoDto): Observable<SlApiResponseOfFloorNoDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/FloorNo/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(floorNoDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateFloorNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateFloorNo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfFloorNoDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfFloorNoDtoAndObject>;
        }));
    }

    protected processUpdateFloorNo(response: HttpResponseBase): Observable<SlApiResponseOfFloorNoDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfFloorNoDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Delete the specified FloorNo
     * @param id int
     * @return SlApiResponse FloorNoDto
     */
    deleteFloorNo(id: number): Observable<SlApiResponseOfFloorNoDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/FloorNo/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFloorNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFloorNo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfFloorNoDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfFloorNoDtoAndObject>;
        }));
    }

    protected processDeleteFloorNo(response: HttpResponseBase): Observable<SlApiResponseOfFloorNoDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfFloorNoDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Virtualy delete the specified FloorNo
     * @param id int
     * @return SlApiResponse FloorNoDto
     */
    disableEnableFloorNo(id: number): Observable<SlApiResponseOfFloorNoDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/FloorNo/DisableEnableFloorNo/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableEnableFloorNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableEnableFloorNo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfFloorNoDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfFloorNoDtoAndObject>;
        }));
    }

    protected processDisableEnableFloorNo(response: HttpResponseBase): Observable<SlApiResponseOfFloorNoDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfFloorNoDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

export interface IFloorTypeClient {
    /**
     * Gets the database FloorType with pagination.
     * @param listId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return PaginatedList FloorTypeDto
     */
    getFloorTypeWithPagination(listId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SlApiResponseOfPaginatedListOfFloorTypeDtoAndObject>;
    /**
     * Create a new FloorType
     * @param floorTypeDto FloorTypeDto
     * @return SlApiResponse FloorTypeDto
     */
    createFloorType(floorTypeDto: FloorTypeDto): Observable<SlApiResponseOfFloorTypeDtoAndObject>;
    /**
     * Gets the specified FloorType.
     * @return PaginatedList FloorTypeDto
     */
    getFloorTypeById(id: number): Observable<SlApiResponseOfFloorTypeDtoAndObject>;
    /**
     * Update the specified FloorType
     * @param floorTypeDto FloorTypeDto
     * @return SlApiResponse FloorTypeDto
     */
    updateFloorType(id: number, floorTypeDto: FloorTypeDto): Observable<SlApiResponseOfFloorTypeDtoAndObject>;
    /**
     * Delete the specified FloorType
     * @param id int
     * @return SlApiResponse FloorTypeDto
     */
    deleteFloorType(id: number): Observable<SlApiResponseOfFloorTypeDtoAndObject>;
    /**
     * Virtualy delete the specified FloorType
     * @param id int
     * @return SlApiResponse FloorTypeDto
     */
    disableEnableFloorType(id: number): Observable<SlApiResponseOfFloorTypeDtoAndObject>;
}

@Injectable({
    providedIn: 'root'
})
export class FloorTypeClient implements IFloorTypeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Gets the database FloorType with pagination.
     * @param listId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return PaginatedList FloorTypeDto
     */
    getFloorTypeWithPagination(listId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SlApiResponseOfPaginatedListOfFloorTypeDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/FloorType?";
        if (listId === null)
            throw new Error("The parameter 'listId' cannot be null.");
        else if (listId !== undefined)
            url_ += "ListId=" + encodeURIComponent("" + listId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFloorTypeWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFloorTypeWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfPaginatedListOfFloorTypeDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfPaginatedListOfFloorTypeDtoAndObject>;
        }));
    }

    protected processGetFloorTypeWithPagination(response: HttpResponseBase): Observable<SlApiResponseOfPaginatedListOfFloorTypeDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("Not Acceptable", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfPaginatedListOfFloorTypeDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Create a new FloorType
     * @param floorTypeDto FloorTypeDto
     * @return SlApiResponse FloorTypeDto
     */
    createFloorType(floorTypeDto: FloorTypeDto): Observable<SlApiResponseOfFloorTypeDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/FloorType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(floorTypeDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFloorType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFloorType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfFloorTypeDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfFloorTypeDtoAndObject>;
        }));
    }

    protected processCreateFloorType(response: HttpResponseBase): Observable<SlApiResponseOfFloorTypeDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfFloorTypeDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Gets the specified FloorType.
     * @return PaginatedList FloorTypeDto
     */
    getFloorTypeById(id: number): Observable<SlApiResponseOfFloorTypeDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/FloorType/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFloorTypeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFloorTypeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfFloorTypeDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfFloorTypeDtoAndObject>;
        }));
    }

    protected processGetFloorTypeById(response: HttpResponseBase): Observable<SlApiResponseOfFloorTypeDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException(" Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException(" Unauthorized ", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException(" Not Acceptable", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException(" Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfFloorTypeDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException(" Not Found", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Update the specified FloorType
     * @param floorTypeDto FloorTypeDto
     * @return SlApiResponse FloorTypeDto
     */
    updateFloorType(id: number, floorTypeDto: FloorTypeDto): Observable<SlApiResponseOfFloorTypeDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/FloorType/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(floorTypeDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateFloorType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateFloorType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfFloorTypeDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfFloorTypeDtoAndObject>;
        }));
    }

    protected processUpdateFloorType(response: HttpResponseBase): Observable<SlApiResponseOfFloorTypeDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfFloorTypeDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Delete the specified FloorType
     * @param id int
     * @return SlApiResponse FloorTypeDto
     */
    deleteFloorType(id: number): Observable<SlApiResponseOfFloorTypeDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/FloorType/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFloorType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFloorType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfFloorTypeDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfFloorTypeDtoAndObject>;
        }));
    }

    protected processDeleteFloorType(response: HttpResponseBase): Observable<SlApiResponseOfFloorTypeDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfFloorTypeDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Virtualy delete the specified FloorType
     * @param id int
     * @return SlApiResponse FloorTypeDto
     */
    disableEnableFloorType(id: number): Observable<SlApiResponseOfFloorTypeDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/FloorType/DisableEnableFloorType/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableEnableFloorType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableEnableFloorType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfFloorTypeDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfFloorTypeDtoAndObject>;
        }));
    }

    protected processDisableEnableFloorType(response: HttpResponseBase): Observable<SlApiResponseOfFloorTypeDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfFloorTypeDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

export interface IFrameTypeClient {
    /**
     * Gets the database FrameType with pagination.
     * @param listId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return PaginatedList FrameTypeDto
     */
    getFrameTypeWithPagination(listId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SlApiResponseOfPaginatedListOfFrameTypeDtoAndObject>;
    /**
     * Create a new FrameType
     * @param frameTypeDto FrameTypeDto
     * @return SlApiResponse FrameTypeDto
     */
    createFrameType(frameTypeDto: FrameTypeDto): Observable<SlApiResponseOfFrameTypeDtoAndObject>;
    /**
     * Gets the specified FrameType.
     * @return PaginatedList FrameTypeDto
     */
    getFrameTypeById(id: number): Observable<SlApiResponseOfFrameTypeDtoAndObject>;
    /**
     * Update the specified FrameType
     * @param frameTypeDto FrameTypeDto
     * @return SlApiResponse FrameTypeDto
     */
    updateFrameType(id: number, frameTypeDto: FrameTypeDto): Observable<SlApiResponseOfFrameTypeDtoAndObject>;
    /**
     * Delete the specified FrameType
     * @param id int
     * @return SlApiResponse FrameTypeDto
     */
    deleteFrameType(id: number): Observable<SlApiResponseOfFrameTypeDtoAndObject>;
    /**
     * Virtualy delete the specified FrameType
     * @param id int
     * @return SlApiResponse FrameTypeDto
     */
    disableEnableFrameType(id: number): Observable<SlApiResponseOfFrameTypeDtoAndObject>;
}

@Injectable({
    providedIn: 'root'
})
export class FrameTypeClient implements IFrameTypeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Gets the database FrameType with pagination.
     * @param listId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return PaginatedList FrameTypeDto
     */
    getFrameTypeWithPagination(listId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SlApiResponseOfPaginatedListOfFrameTypeDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/FrameType?";
        if (listId === null)
            throw new Error("The parameter 'listId' cannot be null.");
        else if (listId !== undefined)
            url_ += "ListId=" + encodeURIComponent("" + listId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFrameTypeWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFrameTypeWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfPaginatedListOfFrameTypeDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfPaginatedListOfFrameTypeDtoAndObject>;
        }));
    }

    protected processGetFrameTypeWithPagination(response: HttpResponseBase): Observable<SlApiResponseOfPaginatedListOfFrameTypeDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("Not Acceptable", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfPaginatedListOfFrameTypeDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Create a new FrameType
     * @param frameTypeDto FrameTypeDto
     * @return SlApiResponse FrameTypeDto
     */
    createFrameType(frameTypeDto: FrameTypeDto): Observable<SlApiResponseOfFrameTypeDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/FrameType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(frameTypeDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFrameType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFrameType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfFrameTypeDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfFrameTypeDtoAndObject>;
        }));
    }

    protected processCreateFrameType(response: HttpResponseBase): Observable<SlApiResponseOfFrameTypeDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfFrameTypeDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Gets the specified FrameType.
     * @return PaginatedList FrameTypeDto
     */
    getFrameTypeById(id: number): Observable<SlApiResponseOfFrameTypeDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/FrameType/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFrameTypeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFrameTypeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfFrameTypeDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfFrameTypeDtoAndObject>;
        }));
    }

    protected processGetFrameTypeById(response: HttpResponseBase): Observable<SlApiResponseOfFrameTypeDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException(" Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException(" Unauthorized ", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException(" Not Acceptable", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException(" Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfFrameTypeDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException(" Not Found", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Update the specified FrameType
     * @param frameTypeDto FrameTypeDto
     * @return SlApiResponse FrameTypeDto
     */
    updateFrameType(id: number, frameTypeDto: FrameTypeDto): Observable<SlApiResponseOfFrameTypeDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/FrameType/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(frameTypeDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateFrameType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateFrameType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfFrameTypeDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfFrameTypeDtoAndObject>;
        }));
    }

    protected processUpdateFrameType(response: HttpResponseBase): Observable<SlApiResponseOfFrameTypeDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfFrameTypeDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Delete the specified FrameType
     * @param id int
     * @return SlApiResponse FrameTypeDto
     */
    deleteFrameType(id: number): Observable<SlApiResponseOfFrameTypeDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/FrameType/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFrameType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFrameType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfFrameTypeDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfFrameTypeDtoAndObject>;
        }));
    }

    protected processDeleteFrameType(response: HttpResponseBase): Observable<SlApiResponseOfFrameTypeDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfFrameTypeDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Virtualy delete the specified FrameType
     * @param id int
     * @return SlApiResponse FrameTypeDto
     */
    disableEnableFrameType(id: number): Observable<SlApiResponseOfFrameTypeDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/FrameType/DisableEnableFrameType/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableEnableFrameType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableEnableFrameType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfFrameTypeDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfFrameTypeDtoAndObject>;
        }));
    }

    protected processDisableEnableFrameType(response: HttpResponseBase): Observable<SlApiResponseOfFrameTypeDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfFrameTypeDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

export interface IGoogleMapPlaceClient {
    /**
     * Gets the database GoogleMapPlace with pagination.
     * @param listId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return PaginatedList GoogleMapPlaceDto
     */
    getGoogleMapPlaceWithPagination(listId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SlApiResponseOfPaginatedListOfGoogleMapPlaceDtoAndObject>;
    /**
     * Create a new GoogleMapPlace
     * @param googleMapPlaceDto GoogleMapPlaceDto
     * @return SlApiResponse GoogleMapPlaceDto
     */
    createGoogleMapPlace(googleMapPlaceDto: GoogleMapPlaceDto): Observable<SlApiResponseOfGoogleMapPlaceDtoAndObject>;
    /**
     * Gets the specified GoogleMapPlace.
     * @return PaginatedList GoogleMapPlaceDto
     */
    getGoogleMapPlaceById(id: number): Observable<SlApiResponseOfGoogleMapPlaceDtoAndObject>;
    /**
     * Update the specified GoogleMapPlace
     * @param googleMapPlaceDto GoogleMapPlaceDto
     * @return SlApiResponse GoogleMapPlaceDto
     */
    updateGoogleMapPlace(id: number, googleMapPlaceDto: GoogleMapPlaceDto): Observable<SlApiResponseOfGoogleMapPlaceDtoAndObject>;
    /**
     * Delete the specified GoogleMapPlace
     * @param id int
     * @return SlApiResponse GoogleMapPlaceDto
     */
    deleteGoogleMapPlace(id: number): Observable<SlApiResponseOfGoogleMapPlaceDtoAndObject>;
    /**
     * Virtualy delete the specified GoogleMapPlace
     * @param id int
     * @return SlApiResponse GoogleMapPlaceDto
     */
    disableEnableGoogleMapPlace(id: number): Observable<SlApiResponseOfGoogleMapPlaceDtoAndObject>;
}

@Injectable({
    providedIn: 'root'
})
export class GoogleMapPlaceClient implements IGoogleMapPlaceClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Gets the database GoogleMapPlace with pagination.
     * @param listId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return PaginatedList GoogleMapPlaceDto
     */
    getGoogleMapPlaceWithPagination(listId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SlApiResponseOfPaginatedListOfGoogleMapPlaceDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/GoogleMapPlace?";
        if (listId === null)
            throw new Error("The parameter 'listId' cannot be null.");
        else if (listId !== undefined)
            url_ += "ListId=" + encodeURIComponent("" + listId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGoogleMapPlaceWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGoogleMapPlaceWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfPaginatedListOfGoogleMapPlaceDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfPaginatedListOfGoogleMapPlaceDtoAndObject>;
        }));
    }

    protected processGetGoogleMapPlaceWithPagination(response: HttpResponseBase): Observable<SlApiResponseOfPaginatedListOfGoogleMapPlaceDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("Not Acceptable", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfPaginatedListOfGoogleMapPlaceDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Create a new GoogleMapPlace
     * @param googleMapPlaceDto GoogleMapPlaceDto
     * @return SlApiResponse GoogleMapPlaceDto
     */
    createGoogleMapPlace(googleMapPlaceDto: GoogleMapPlaceDto): Observable<SlApiResponseOfGoogleMapPlaceDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/GoogleMapPlace";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(googleMapPlaceDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateGoogleMapPlace(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateGoogleMapPlace(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfGoogleMapPlaceDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfGoogleMapPlaceDtoAndObject>;
        }));
    }

    protected processCreateGoogleMapPlace(response: HttpResponseBase): Observable<SlApiResponseOfGoogleMapPlaceDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfGoogleMapPlaceDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Gets the specified GoogleMapPlace.
     * @return PaginatedList GoogleMapPlaceDto
     */
    getGoogleMapPlaceById(id: number): Observable<SlApiResponseOfGoogleMapPlaceDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/GoogleMapPlace/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGoogleMapPlaceById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGoogleMapPlaceById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfGoogleMapPlaceDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfGoogleMapPlaceDtoAndObject>;
        }));
    }

    protected processGetGoogleMapPlaceById(response: HttpResponseBase): Observable<SlApiResponseOfGoogleMapPlaceDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException(" Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException(" Unauthorized ", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException(" Not Acceptable", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException(" Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfGoogleMapPlaceDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException(" Not Found", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Update the specified GoogleMapPlace
     * @param googleMapPlaceDto GoogleMapPlaceDto
     * @return SlApiResponse GoogleMapPlaceDto
     */
    updateGoogleMapPlace(id: number, googleMapPlaceDto: GoogleMapPlaceDto): Observable<SlApiResponseOfGoogleMapPlaceDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/GoogleMapPlace/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(googleMapPlaceDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGoogleMapPlace(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGoogleMapPlace(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfGoogleMapPlaceDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfGoogleMapPlaceDtoAndObject>;
        }));
    }

    protected processUpdateGoogleMapPlace(response: HttpResponseBase): Observable<SlApiResponseOfGoogleMapPlaceDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfGoogleMapPlaceDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Delete the specified GoogleMapPlace
     * @param id int
     * @return SlApiResponse GoogleMapPlaceDto
     */
    deleteGoogleMapPlace(id: number): Observable<SlApiResponseOfGoogleMapPlaceDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/GoogleMapPlace/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteGoogleMapPlace(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteGoogleMapPlace(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfGoogleMapPlaceDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfGoogleMapPlaceDtoAndObject>;
        }));
    }

    protected processDeleteGoogleMapPlace(response: HttpResponseBase): Observable<SlApiResponseOfGoogleMapPlaceDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfGoogleMapPlaceDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Virtualy delete the specified GoogleMapPlace
     * @param id int
     * @return SlApiResponse GoogleMapPlaceDto
     */
    disableEnableGoogleMapPlace(id: number): Observable<SlApiResponseOfGoogleMapPlaceDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/GoogleMapPlace/DisableEnableGoogleMapPlace/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableEnableGoogleMapPlace(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableEnableGoogleMapPlace(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfGoogleMapPlaceDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfGoogleMapPlaceDtoAndObject>;
        }));
    }

    protected processDisableEnableGoogleMapPlace(response: HttpResponseBase): Observable<SlApiResponseOfGoogleMapPlaceDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfGoogleMapPlaceDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

export interface IHeatingSystemClient {
    /**
     * Gets the database HeatingSystem with pagination.
     * @param listId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return PaginatedList HeatingSystemDto
     */
    getHeatingSystemWithPagination(listId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SlApiResponseOfPaginatedListOfHeatingSystemDtoAndObject>;
    /**
     * Create a new HeatingSystem
     * @param heatingSystemDto HeatingSystemDto
     * @return SlApiResponse HeatingSystemDto
     */
    createHeatingSystem(heatingSystemDto: HeatingSystemDto): Observable<SlApiResponseOfHeatingSystemDtoAndObject>;
    /**
     * Gets the specified HeatingSystem.
     * @return PaginatedList HeatingSystemDto
     */
    getHeatingSystemById(id: number): Observable<SlApiResponseOfHeatingSystemDtoAndObject>;
    /**
     * Update the specified HeatingSystem
     * @param heatingSystemDto HeatingSystemDto
     * @return SlApiResponse HeatingSystemDto
     */
    updateHeatingSystem(id: number, heatingSystemDto: HeatingSystemDto): Observable<SlApiResponseOfHeatingSystemDtoAndObject>;
    /**
     * Delete the specified HeatingSystem
     * @param id int
     * @return SlApiResponse HeatingSystemDto
     */
    deleteHeatingSystem(id: number): Observable<SlApiResponseOfHeatingSystemDtoAndObject>;
    /**
     * Virtualy delete the specified HeatingSystem
     * @param id int
     * @return SlApiResponse HeatingSystemDto
     */
    disableEnableHeatingSystem(id: number): Observable<SlApiResponseOfHeatingSystemDtoAndObject>;
}

@Injectable({
    providedIn: 'root'
})
export class HeatingSystemClient implements IHeatingSystemClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Gets the database HeatingSystem with pagination.
     * @param listId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return PaginatedList HeatingSystemDto
     */
    getHeatingSystemWithPagination(listId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<SlApiResponseOfPaginatedListOfHeatingSystemDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/HeatingSystem?";
        if (listId === null)
            throw new Error("The parameter 'listId' cannot be null.");
        else if (listId !== undefined)
            url_ += "ListId=" + encodeURIComponent("" + listId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHeatingSystemWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHeatingSystemWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfPaginatedListOfHeatingSystemDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfPaginatedListOfHeatingSystemDtoAndObject>;
        }));
    }

    protected processGetHeatingSystemWithPagination(response: HttpResponseBase): Observable<SlApiResponseOfPaginatedListOfHeatingSystemDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("Not Acceptable", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfPaginatedListOfHeatingSystemDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Create a new HeatingSystem
     * @param heatingSystemDto HeatingSystemDto
     * @return SlApiResponse HeatingSystemDto
     */
    createHeatingSystem(heatingSystemDto: HeatingSystemDto): Observable<SlApiResponseOfHeatingSystemDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/HeatingSystem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(heatingSystemDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateHeatingSystem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateHeatingSystem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfHeatingSystemDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfHeatingSystemDtoAndObject>;
        }));
    }

    protected processCreateHeatingSystem(response: HttpResponseBase): Observable<SlApiResponseOfHeatingSystemDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfHeatingSystemDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Gets the specified HeatingSystem.
     * @return PaginatedList HeatingSystemDto
     */
    getHeatingSystemById(id: number): Observable<SlApiResponseOfHeatingSystemDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/HeatingSystem/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHeatingSystemById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHeatingSystemById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfHeatingSystemDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfHeatingSystemDtoAndObject>;
        }));
    }

    protected processGetHeatingSystemById(response: HttpResponseBase): Observable<SlApiResponseOfHeatingSystemDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException(" Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException(" Unauthorized ", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException(" Not Acceptable", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException(" Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfHeatingSystemDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException(" Not Found", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Update the specified HeatingSystem
     * @param heatingSystemDto HeatingSystemDto
     * @return SlApiResponse HeatingSystemDto
     */
    updateHeatingSystem(id: number, heatingSystemDto: HeatingSystemDto): Observable<SlApiResponseOfHeatingSystemDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/HeatingSystem/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(heatingSystemDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateHeatingSystem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateHeatingSystem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfHeatingSystemDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfHeatingSystemDtoAndObject>;
        }));
    }

    protected processUpdateHeatingSystem(response: HttpResponseBase): Observable<SlApiResponseOfHeatingSystemDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfHeatingSystemDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Delete the specified HeatingSystem
     * @param id int
     * @return SlApiResponse HeatingSystemDto
     */
    deleteHeatingSystem(id: number): Observable<SlApiResponseOfHeatingSystemDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/HeatingSystem/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteHeatingSystem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteHeatingSystem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfHeatingSystemDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfHeatingSystemDtoAndObject>;
        }));
    }

    protected processDeleteHeatingSystem(response: HttpResponseBase): Observable<SlApiResponseOfHeatingSystemDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfHeatingSystemDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * Virtualy delete the specified HeatingSystem
     * @param id int
     * @return SlApiResponse HeatingSystemDto
     */
    disableEnableHeatingSystem(id: number): Observable<SlApiResponseOfHeatingSystemDtoAndObject> {
        let url_ = this.baseUrl + "/api/v1/HeatingSystem/DisableEnableHeatingSystem/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableEnableHeatingSystem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableEnableHeatingSystem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlApiResponseOfHeatingSystemDtoAndObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlApiResponseOfHeatingSystemDtoAndObject>;
        }));
    }

    protected processDisableEnableHeatingSystem(response: HttpResponseBase): Observable<SlApiResponseOfHeatingSystemDtoAndObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 406) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ProblemDetails.fromJS(resultData406);
            return throwException("A server side error occurred.", status, _responseText, _headers, result406);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SlApiResponseOfHeatingSystemDtoAndObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
}

export class SlApiResponseOfPaginatedListOfAdvertiserInfoDtoAndObject implements ISlApiResponseOfPaginatedListOfAdvertiserInfoDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: PaginatedListOfAdvertiserInfoDto | undefined;
    metaData?: any | undefined;

    constructor(data?: ISlApiResponseOfPaginatedListOfAdvertiserInfoDtoAndObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(SlApiMessage.fromJS(item));
            }
            this.data = _data["data"] ? PaginatedListOfAdvertiserInfoDto.fromJS(_data["data"]) : <any>undefined;
            this.metaData = _data["metaData"];
        }
    }

    static fromJS(data: any): SlApiResponseOfPaginatedListOfAdvertiserInfoDtoAndObject {
        data = typeof data === 'object' ? data : {};
        let result = new SlApiResponseOfPaginatedListOfAdvertiserInfoDtoAndObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["metaData"] = this.metaData;
        return data;
    }
}

export interface ISlApiResponseOfPaginatedListOfAdvertiserInfoDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: PaginatedListOfAdvertiserInfoDto | undefined;
    metaData?: any | undefined;
}

export class SlApiMessage implements ISlApiMessage {
    messageType?: SlApiMessageTypeEnum;
    message?: string | undefined;

    constructor(data?: ISlApiMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.messageType = _data["messageType"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): SlApiMessage {
        data = typeof data === 'object' ? data : {};
        let result = new SlApiMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["messageType"] = this.messageType;
        data["message"] = this.message;
        return data;
    }
}

export interface ISlApiMessage {
    messageType?: SlApiMessageTypeEnum;
    message?: string | undefined;
}

export enum SlApiMessageTypeEnum {
    Error = 0,
    Warning = 1,
    Information = 2,
}

export class PaginatedListOfAdvertiserInfoDto implements IPaginatedListOfAdvertiserInfoDto {
    items?: AdvertiserInfoDto[] | undefined;
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfAdvertiserInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AdvertiserInfoDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfAdvertiserInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfAdvertiserInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfAdvertiserInfoDto {
    items?: AdvertiserInfoDto[] | undefined;
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export abstract class AuditableEntity implements IAuditableEntity {
    guid?: string;
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date | undefined;
    lastModifiedBy?: string | undefined;

    constructor(data?: IAuditableEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guid = _data["guid"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
        }
    }

    static fromJS(data: any): AuditableEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AuditableEntity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["guid"] = this.guid;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        return data;
    }
}

export interface IAuditableEntity {
    guid?: string;
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date | undefined;
    lastModifiedBy?: string | undefined;
}

export class AdvertiserInfoDto extends AuditableEntity implements IAdvertiserInfoDto {
    advertiserInfoID?: number;
    code?: string | undefined;
    name?: string | undefined;
    address?: string | undefined;
    responsible?: string | undefined;
    telephone?: string | undefined;
    email?: string | undefined;
    website?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classifieds?: ClassifiedDto[] | undefined;

    constructor(data?: IAdvertiserInfoDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.advertiserInfoID = _data["advertiserInfoID"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.address = _data["address"];
            this.responsible = _data["responsible"];
            this.telephone = _data["telephone"];
            this.email = _data["email"];
            this.website = _data["website"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["classifieds"])) {
                this.classifieds = [] as any;
                for (let item of _data["classifieds"])
                    this.classifieds!.push(ClassifiedDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdvertiserInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdvertiserInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["advertiserInfoID"] = this.advertiserInfoID;
        data["code"] = this.code;
        data["name"] = this.name;
        data["address"] = this.address;
        data["responsible"] = this.responsible;
        data["telephone"] = this.telephone;
        data["email"] = this.email;
        data["website"] = this.website;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.classifieds)) {
            data["classifieds"] = [];
            for (let item of this.classifieds)
                data["classifieds"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IAdvertiserInfoDto extends IAuditableEntity {
    advertiserInfoID?: number;
    code?: string | undefined;
    name?: string | undefined;
    address?: string | undefined;
    responsible?: string | undefined;
    telephone?: string | undefined;
    email?: string | undefined;
    website?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classifieds?: ClassifiedDto[] | undefined;
}

export class ClassifiedDto extends AuditableEntity implements IClassifiedDto {
    classifiedID?: number;
    purposeID?: number;
    classifiedPurpose?: ClassifiedPurposeDto | undefined;
    typeID?: number;
    classifiedType?: ClassifiedTypeDto | undefined;
    exteriorFeaturesID?: number;
    exteriorFeature?: ExteriorFeatureDto | undefined;
    interiorFeaturesID?: number;
    interiorFeature?: InteriorFeatureDto | undefined;
    googleMapPlaceID?: number;
    googleMapPlace?: GoogleMapPlaceDto | undefined;
    advertiserInfoID?: number;
    advertiserInfo?: AdvertiserInfoDto | undefined;
    suitableForID?: number;
    suitableFor?: SuitableForDto | undefined;
    floorNoID?: number;
    floorNo?: FloorNoDto | undefined;
    characteristicsID?: number;
    classifiedCharacteristics?: ClassifiedCharacteristicsDto | undefined;
    photos?: PhotosDto[] | undefined;
    classifiedTitle?: string | undefined;
    classifiedDesription?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;

    constructor(data?: IClassifiedDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.classifiedID = _data["classifiedID"];
            this.purposeID = _data["purposeID"];
            this.classifiedPurpose = _data["classifiedPurpose"] ? ClassifiedPurposeDto.fromJS(_data["classifiedPurpose"]) : <any>undefined;
            this.typeID = _data["typeID"];
            this.classifiedType = _data["classifiedType"] ? ClassifiedTypeDto.fromJS(_data["classifiedType"]) : <any>undefined;
            this.exteriorFeaturesID = _data["exteriorFeaturesID"];
            this.exteriorFeature = _data["exteriorFeature"] ? ExteriorFeatureDto.fromJS(_data["exteriorFeature"]) : <any>undefined;
            this.interiorFeaturesID = _data["interiorFeaturesID"];
            this.interiorFeature = _data["interiorFeature"] ? InteriorFeatureDto.fromJS(_data["interiorFeature"]) : <any>undefined;
            this.googleMapPlaceID = _data["googleMapPlaceID"];
            this.googleMapPlace = _data["googleMapPlace"] ? GoogleMapPlaceDto.fromJS(_data["googleMapPlace"]) : <any>undefined;
            this.advertiserInfoID = _data["advertiserInfoID"];
            this.advertiserInfo = _data["advertiserInfo"] ? AdvertiserInfoDto.fromJS(_data["advertiserInfo"]) : <any>undefined;
            this.suitableForID = _data["suitableForID"];
            this.suitableFor = _data["suitableFor"] ? SuitableForDto.fromJS(_data["suitableFor"]) : <any>undefined;
            this.floorNoID = _data["floorNoID"];
            this.floorNo = _data["floorNo"] ? FloorNoDto.fromJS(_data["floorNo"]) : <any>undefined;
            this.characteristicsID = _data["characteristicsID"];
            this.classifiedCharacteristics = _data["classifiedCharacteristics"] ? ClassifiedCharacteristicsDto.fromJS(_data["classifiedCharacteristics"]) : <any>undefined;
            if (Array.isArray(_data["photos"])) {
                this.photos = [] as any;
                for (let item of _data["photos"])
                    this.photos!.push(PhotosDto.fromJS(item));
            }
            this.classifiedTitle = _data["classifiedTitle"];
            this.classifiedDesription = _data["classifiedDesription"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
        }
    }

    static fromJS(data: any): ClassifiedDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClassifiedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classifiedID"] = this.classifiedID;
        data["purposeID"] = this.purposeID;
        data["classifiedPurpose"] = this.classifiedPurpose ? this.classifiedPurpose.toJSON() : <any>undefined;
        data["typeID"] = this.typeID;
        data["classifiedType"] = this.classifiedType ? this.classifiedType.toJSON() : <any>undefined;
        data["exteriorFeaturesID"] = this.exteriorFeaturesID;
        data["exteriorFeature"] = this.exteriorFeature ? this.exteriorFeature.toJSON() : <any>undefined;
        data["interiorFeaturesID"] = this.interiorFeaturesID;
        data["interiorFeature"] = this.interiorFeature ? this.interiorFeature.toJSON() : <any>undefined;
        data["googleMapPlaceID"] = this.googleMapPlaceID;
        data["googleMapPlace"] = this.googleMapPlace ? this.googleMapPlace.toJSON() : <any>undefined;
        data["advertiserInfoID"] = this.advertiserInfoID;
        data["advertiserInfo"] = this.advertiserInfo ? this.advertiserInfo.toJSON() : <any>undefined;
        data["suitableForID"] = this.suitableForID;
        data["suitableFor"] = this.suitableFor ? this.suitableFor.toJSON() : <any>undefined;
        data["floorNoID"] = this.floorNoID;
        data["floorNo"] = this.floorNo ? this.floorNo.toJSON() : <any>undefined;
        data["characteristicsID"] = this.characteristicsID;
        data["classifiedCharacteristics"] = this.classifiedCharacteristics ? this.classifiedCharacteristics.toJSON() : <any>undefined;
        if (Array.isArray(this.photos)) {
            data["photos"] = [];
            for (let item of this.photos)
                data["photos"].push(item.toJSON());
        }
        data["classifiedTitle"] = this.classifiedTitle;
        data["classifiedDesription"] = this.classifiedDesription;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        super.toJSON(data);
        return data;
    }
}

export interface IClassifiedDto extends IAuditableEntity {
    classifiedID?: number;
    purposeID?: number;
    classifiedPurpose?: ClassifiedPurposeDto | undefined;
    typeID?: number;
    classifiedType?: ClassifiedTypeDto | undefined;
    exteriorFeaturesID?: number;
    exteriorFeature?: ExteriorFeatureDto | undefined;
    interiorFeaturesID?: number;
    interiorFeature?: InteriorFeatureDto | undefined;
    googleMapPlaceID?: number;
    googleMapPlace?: GoogleMapPlaceDto | undefined;
    advertiserInfoID?: number;
    advertiserInfo?: AdvertiserInfoDto | undefined;
    suitableForID?: number;
    suitableFor?: SuitableForDto | undefined;
    floorNoID?: number;
    floorNo?: FloorNoDto | undefined;
    characteristicsID?: number;
    classifiedCharacteristics?: ClassifiedCharacteristicsDto | undefined;
    photos?: PhotosDto[] | undefined;
    classifiedTitle?: string | undefined;
    classifiedDesription?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
}

export class ClassifiedPurposeDto extends AuditableEntity implements IClassifiedPurposeDto {
    purposeID?: number;
    title?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classifieds?: ClassifiedDto[] | undefined;

    constructor(data?: IClassifiedPurposeDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.purposeID = _data["purposeID"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["classifieds"])) {
                this.classifieds = [] as any;
                for (let item of _data["classifieds"])
                    this.classifieds!.push(ClassifiedDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClassifiedPurposeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClassifiedPurposeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purposeID"] = this.purposeID;
        data["title"] = this.title;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.classifieds)) {
            data["classifieds"] = [];
            for (let item of this.classifieds)
                data["classifieds"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IClassifiedPurposeDto extends IAuditableEntity {
    purposeID?: number;
    title?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classifieds?: ClassifiedDto[] | undefined;
}

export class ClassifiedTypeDto extends AuditableEntity implements IClassifiedTypeDto {
    typeID?: number;
    title?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classifieds?: ClassifiedDto[] | undefined;

    constructor(data?: IClassifiedTypeDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.typeID = _data["typeID"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["classifieds"])) {
                this.classifieds = [] as any;
                for (let item of _data["classifieds"])
                    this.classifieds!.push(ClassifiedDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClassifiedTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClassifiedTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeID"] = this.typeID;
        data["title"] = this.title;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.classifieds)) {
            data["classifieds"] = [];
            for (let item of this.classifieds)
                data["classifieds"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IClassifiedTypeDto extends IAuditableEntity {
    typeID?: number;
    title?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classifieds?: ClassifiedDto[] | undefined;
}

export class ExteriorFeatureDto extends AuditableEntity implements IExteriorFeatureDto {
    exteriorFeaturesID?: number;
    propertyView?: boolean;
    facade?: boolean;
    orientation?: string | undefined;
    accessFrom?: string | undefined;
    residentialZone?: boolean;
    parkingSpot?: boolean;
    awnings?: boolean;
    garden?: boolean;
    disabledAccess?: boolean;
    pool?: boolean;
    corner?: boolean;
    veranda?: boolean;
    showcaseGlassLength?: number | undefined;
    unloadingRamp?: boolean | undefined;
    withinCityPlan?: boolean;
    structureFactor?: number;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classified?: ClassifiedDto | undefined;

    constructor(data?: IExteriorFeatureDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.exteriorFeaturesID = _data["exteriorFeaturesID"];
            this.propertyView = _data["propertyView"];
            this.facade = _data["facade"];
            this.orientation = _data["orientation"];
            this.accessFrom = _data["accessFrom"];
            this.residentialZone = _data["residentialZone"];
            this.parkingSpot = _data["parkingSpot"];
            this.awnings = _data["awnings"];
            this.garden = _data["garden"];
            this.disabledAccess = _data["disabledAccess"];
            this.pool = _data["pool"];
            this.corner = _data["corner"];
            this.veranda = _data["veranda"];
            this.showcaseGlassLength = _data["showcaseGlassLength"];
            this.unloadingRamp = _data["unloadingRamp"];
            this.withinCityPlan = _data["withinCityPlan"];
            this.structureFactor = _data["structureFactor"];
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
            this.classified = _data["classified"] ? ClassifiedDto.fromJS(_data["classified"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExteriorFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExteriorFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exteriorFeaturesID"] = this.exteriorFeaturesID;
        data["propertyView"] = this.propertyView;
        data["facade"] = this.facade;
        data["orientation"] = this.orientation;
        data["accessFrom"] = this.accessFrom;
        data["residentialZone"] = this.residentialZone;
        data["parkingSpot"] = this.parkingSpot;
        data["awnings"] = this.awnings;
        data["garden"] = this.garden;
        data["disabledAccess"] = this.disabledAccess;
        data["pool"] = this.pool;
        data["corner"] = this.corner;
        data["veranda"] = this.veranda;
        data["showcaseGlassLength"] = this.showcaseGlassLength;
        data["unloadingRamp"] = this.unloadingRamp;
        data["withinCityPlan"] = this.withinCityPlan;
        data["structureFactor"] = this.structureFactor;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        data["classified"] = this.classified ? this.classified.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IExteriorFeatureDto extends IAuditableEntity {
    exteriorFeaturesID?: number;
    propertyView?: boolean;
    facade?: boolean;
    orientation?: string | undefined;
    accessFrom?: string | undefined;
    residentialZone?: boolean;
    parkingSpot?: boolean;
    awnings?: boolean;
    garden?: boolean;
    disabledAccess?: boolean;
    pool?: boolean;
    corner?: boolean;
    veranda?: boolean;
    showcaseGlassLength?: number | undefined;
    unloadingRamp?: boolean | undefined;
    withinCityPlan?: boolean;
    structureFactor?: number;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classified?: ClassifiedDto | undefined;
}

export class InteriorFeatureDto extends AuditableEntity implements IInteriorFeatureDto {
    interiorFeaturesID?: number;
    elevator?: boolean;
    internalStaircase?: boolean;
    airConditioning?: boolean;
    warehouse?: boolean;
    floorTypeID?: number;
    floorType?: FloorTypeDto | undefined;
    petsWelcome?: boolean;
    securityDoor?: boolean;
    frameTypeID?: number;
    frameType?: FrameTypeDto | undefined;
    powerTypeID?: number;
    powerType?: PowerTypeDto | undefined;
    doubleGlazing?: boolean;
    furnished?: boolean;
    fireplace?: boolean;
    underfloorHeating?: boolean;
    solarHeating?: boolean;
    nightCurrent?: boolean;
    garret?: boolean;
    playroom?: boolean;
    satelliteAntenna?: boolean;
    alarm?: boolean;
    doorScreens?: boolean;
    airy?: boolean;
    painted?: boolean;
    withEquipment?: boolean;
    cableTV?: boolean;
    wiring?: boolean;
    loadingUnloadingElevator?: boolean;
    suspendedCeiling?: boolean;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classified?: ClassifiedDto | undefined;

    constructor(data?: IInteriorFeatureDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.interiorFeaturesID = _data["interiorFeaturesID"];
            this.elevator = _data["elevator"];
            this.internalStaircase = _data["internalStaircase"];
            this.airConditioning = _data["airConditioning"];
            this.warehouse = _data["warehouse"];
            this.floorTypeID = _data["floorTypeID"];
            this.floorType = _data["floorType"] ? FloorTypeDto.fromJS(_data["floorType"]) : <any>undefined;
            this.petsWelcome = _data["petsWelcome"];
            this.securityDoor = _data["securityDoor"];
            this.frameTypeID = _data["frameTypeID"];
            this.frameType = _data["frameType"] ? FrameTypeDto.fromJS(_data["frameType"]) : <any>undefined;
            this.powerTypeID = _data["powerTypeID"];
            this.powerType = _data["powerType"] ? PowerTypeDto.fromJS(_data["powerType"]) : <any>undefined;
            this.doubleGlazing = _data["doubleGlazing"];
            this.furnished = _data["furnished"];
            this.fireplace = _data["fireplace"];
            this.underfloorHeating = _data["underfloorHeating"];
            this.solarHeating = _data["solarHeating"];
            this.nightCurrent = _data["nightCurrent"];
            this.garret = _data["garret"];
            this.playroom = _data["playroom"];
            this.satelliteAntenna = _data["satelliteAntenna"];
            this.alarm = _data["alarm"];
            this.doorScreens = _data["doorScreens"];
            this.airy = _data["airy"];
            this.painted = _data["painted"];
            this.withEquipment = _data["withEquipment"];
            this.cableTV = _data["cableTV"];
            this.wiring = _data["wiring"];
            this.loadingUnloadingElevator = _data["loadingUnloadingElevator"];
            this.suspendedCeiling = _data["suspendedCeiling"];
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
            this.classified = _data["classified"] ? ClassifiedDto.fromJS(_data["classified"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InteriorFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new InteriorFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["interiorFeaturesID"] = this.interiorFeaturesID;
        data["elevator"] = this.elevator;
        data["internalStaircase"] = this.internalStaircase;
        data["airConditioning"] = this.airConditioning;
        data["warehouse"] = this.warehouse;
        data["floorTypeID"] = this.floorTypeID;
        data["floorType"] = this.floorType ? this.floorType.toJSON() : <any>undefined;
        data["petsWelcome"] = this.petsWelcome;
        data["securityDoor"] = this.securityDoor;
        data["frameTypeID"] = this.frameTypeID;
        data["frameType"] = this.frameType ? this.frameType.toJSON() : <any>undefined;
        data["powerTypeID"] = this.powerTypeID;
        data["powerType"] = this.powerType ? this.powerType.toJSON() : <any>undefined;
        data["doubleGlazing"] = this.doubleGlazing;
        data["furnished"] = this.furnished;
        data["fireplace"] = this.fireplace;
        data["underfloorHeating"] = this.underfloorHeating;
        data["solarHeating"] = this.solarHeating;
        data["nightCurrent"] = this.nightCurrent;
        data["garret"] = this.garret;
        data["playroom"] = this.playroom;
        data["satelliteAntenna"] = this.satelliteAntenna;
        data["alarm"] = this.alarm;
        data["doorScreens"] = this.doorScreens;
        data["airy"] = this.airy;
        data["painted"] = this.painted;
        data["withEquipment"] = this.withEquipment;
        data["cableTV"] = this.cableTV;
        data["wiring"] = this.wiring;
        data["loadingUnloadingElevator"] = this.loadingUnloadingElevator;
        data["suspendedCeiling"] = this.suspendedCeiling;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        data["classified"] = this.classified ? this.classified.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IInteriorFeatureDto extends IAuditableEntity {
    interiorFeaturesID?: number;
    elevator?: boolean;
    internalStaircase?: boolean;
    airConditioning?: boolean;
    warehouse?: boolean;
    floorTypeID?: number;
    floorType?: FloorTypeDto | undefined;
    petsWelcome?: boolean;
    securityDoor?: boolean;
    frameTypeID?: number;
    frameType?: FrameTypeDto | undefined;
    powerTypeID?: number;
    powerType?: PowerTypeDto | undefined;
    doubleGlazing?: boolean;
    furnished?: boolean;
    fireplace?: boolean;
    underfloorHeating?: boolean;
    solarHeating?: boolean;
    nightCurrent?: boolean;
    garret?: boolean;
    playroom?: boolean;
    satelliteAntenna?: boolean;
    alarm?: boolean;
    doorScreens?: boolean;
    airy?: boolean;
    painted?: boolean;
    withEquipment?: boolean;
    cableTV?: boolean;
    wiring?: boolean;
    loadingUnloadingElevator?: boolean;
    suspendedCeiling?: boolean;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classified?: ClassifiedDto | undefined;
}

export class FloorTypeDto extends AuditableEntity implements IFloorTypeDto {
    floorTypeID?: number;
    title?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    interiorFeatures?: InteriorFeatureDto[] | undefined;

    constructor(data?: IFloorTypeDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.floorTypeID = _data["floorTypeID"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["interiorFeatures"])) {
                this.interiorFeatures = [] as any;
                for (let item of _data["interiorFeatures"])
                    this.interiorFeatures!.push(InteriorFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FloorTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new FloorTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["floorTypeID"] = this.floorTypeID;
        data["title"] = this.title;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.interiorFeatures)) {
            data["interiorFeatures"] = [];
            for (let item of this.interiorFeatures)
                data["interiorFeatures"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IFloorTypeDto extends IAuditableEntity {
    floorTypeID?: number;
    title?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    interiorFeatures?: InteriorFeatureDto[] | undefined;
}

export class FrameTypeDto extends AuditableEntity implements IFrameTypeDto {
    frameTypeID?: number;
    title?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    interiorFeatures?: InteriorFeatureDto[] | undefined;

    constructor(data?: IFrameTypeDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.frameTypeID = _data["frameTypeID"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["interiorFeatures"])) {
                this.interiorFeatures = [] as any;
                for (let item of _data["interiorFeatures"])
                    this.interiorFeatures!.push(InteriorFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FrameTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new FrameTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["frameTypeID"] = this.frameTypeID;
        data["title"] = this.title;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.interiorFeatures)) {
            data["interiorFeatures"] = [];
            for (let item of this.interiorFeatures)
                data["interiorFeatures"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IFrameTypeDto extends IAuditableEntity {
    frameTypeID?: number;
    title?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    interiorFeatures?: InteriorFeatureDto[] | undefined;
}

export class PowerTypeDto extends AuditableEntity implements IPowerTypeDto {
    powerTypeID?: number;
    title?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    interiorFeatures?: InteriorFeatureDto[] | undefined;

    constructor(data?: IPowerTypeDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.powerTypeID = _data["powerTypeID"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["interiorFeatures"])) {
                this.interiorFeatures = [] as any;
                for (let item of _data["interiorFeatures"])
                    this.interiorFeatures!.push(InteriorFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PowerTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PowerTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["powerTypeID"] = this.powerTypeID;
        data["title"] = this.title;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.interiorFeatures)) {
            data["interiorFeatures"] = [];
            for (let item of this.interiorFeatures)
                data["interiorFeatures"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPowerTypeDto extends IAuditableEntity {
    powerTypeID?: number;
    title?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    interiorFeatures?: InteriorFeatureDto[] | undefined;
}

export class GoogleMapPlaceDto extends AuditableEntity implements IGoogleMapPlaceDto {
    googleMapPlaceID?: number;
    area?: string | undefined;
    latitude?: string | undefined;
    longitude?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classified?: ClassifiedDto | undefined;

    constructor(data?: IGoogleMapPlaceDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.googleMapPlaceID = _data["googleMapPlaceID"];
            this.area = _data["area"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
            this.classified = _data["classified"] ? ClassifiedDto.fromJS(_data["classified"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GoogleMapPlaceDto {
        data = typeof data === 'object' ? data : {};
        let result = new GoogleMapPlaceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["googleMapPlaceID"] = this.googleMapPlaceID;
        data["area"] = this.area;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        data["classified"] = this.classified ? this.classified.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IGoogleMapPlaceDto extends IAuditableEntity {
    googleMapPlaceID?: number;
    area?: string | undefined;
    latitude?: string | undefined;
    longitude?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classified?: ClassifiedDto | undefined;
}

export class SuitableForDto implements ISuitableForDto {
    suitableForID?: number;
    studentUse?: boolean;
    holidayHomeUse?: boolean;
    professionalUse?: boolean;
    investmentUse?: boolean;
    touristRentalUse?: boolean;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classified?: ClassifiedDto | undefined;

    constructor(data?: ISuitableForDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.suitableForID = _data["suitableForID"];
            this.studentUse = _data["studentUse"];
            this.holidayHomeUse = _data["holidayHomeUse"];
            this.professionalUse = _data["professionalUse"];
            this.investmentUse = _data["investmentUse"];
            this.touristRentalUse = _data["touristRentalUse"];
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
            this.classified = _data["classified"] ? ClassifiedDto.fromJS(_data["classified"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SuitableForDto {
        data = typeof data === 'object' ? data : {};
        let result = new SuitableForDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["suitableForID"] = this.suitableForID;
        data["studentUse"] = this.studentUse;
        data["holidayHomeUse"] = this.holidayHomeUse;
        data["professionalUse"] = this.professionalUse;
        data["investmentUse"] = this.investmentUse;
        data["touristRentalUse"] = this.touristRentalUse;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        data["classified"] = this.classified ? this.classified.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISuitableForDto {
    suitableForID?: number;
    studentUse?: boolean;
    holidayHomeUse?: boolean;
    professionalUse?: boolean;
    investmentUse?: boolean;
    touristRentalUse?: boolean;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classified?: ClassifiedDto | undefined;
}

export class FloorNoDto extends AuditableEntity implements IFloorNoDto {
    floorNoID?: number;
    floorNoValue?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classifieds?: ClassifiedDto[] | undefined;

    constructor(data?: IFloorNoDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.floorNoID = _data["floorNoID"];
            this.floorNoValue = _data["floorNoValue"];
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["classifieds"])) {
                this.classifieds = [] as any;
                for (let item of _data["classifieds"])
                    this.classifieds!.push(ClassifiedDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FloorNoDto {
        data = typeof data === 'object' ? data : {};
        let result = new FloorNoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["floorNoID"] = this.floorNoID;
        data["floorNoValue"] = this.floorNoValue;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.classifieds)) {
            data["classifieds"] = [];
            for (let item of this.classifieds)
                data["classifieds"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IFloorNoDto extends IAuditableEntity {
    floorNoID?: number;
    floorNoValue?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classifieds?: ClassifiedDto[] | undefined;
}

export class ClassifiedCharacteristicsDto extends AuditableEntity implements IClassifiedCharacteristicsDto {
    characteristicsID?: number;
    price?: number;
    pricePerTm?: number;
    areaTm?: number;
    landAreaTm?: number;
    levels?: number;
    square?: number;
    region?: string | undefined;
    cuisines?: number;
    bathrooms?: number;
    bedrooms?: number;
    heatingTypeID?: number;
    heatingType?: HeatingTypeDto | undefined;
    heatingSystemID?: number;
    heatingSystem?: HeatingSystemDto | undefined;
    energyClassID?: number;
    energyClass?: EnergyClassDto | undefined;
    contructionYear?: number;
    landArea?: number;
    lounges?: number;
    monthlyShared?: number;
    distanceFromSea?: number;
    yearOfRenovation?: number;
    buildingCoefficient?: number;
    systemCode?: string | undefined;
    propertyCode?: string | undefined;
    availableFrom?: Date | undefined;
    publicationOfAdvert?: Date | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classified?: ClassifiedDto | undefined;

    constructor(data?: IClassifiedCharacteristicsDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.characteristicsID = _data["characteristicsID"];
            this.price = _data["price"];
            this.pricePerTm = _data["pricePerTm"];
            this.areaTm = _data["areaTm"];
            this.landAreaTm = _data["landAreaTm"];
            this.levels = _data["levels"];
            this.square = _data["square"];
            this.region = _data["region"];
            this.cuisines = _data["cuisines"];
            this.bathrooms = _data["bathrooms"];
            this.bedrooms = _data["bedrooms"];
            this.heatingTypeID = _data["heatingTypeID"];
            this.heatingType = _data["heatingType"] ? HeatingTypeDto.fromJS(_data["heatingType"]) : <any>undefined;
            this.heatingSystemID = _data["heatingSystemID"];
            this.heatingSystem = _data["heatingSystem"] ? HeatingSystemDto.fromJS(_data["heatingSystem"]) : <any>undefined;
            this.energyClassID = _data["energyClassID"];
            this.energyClass = _data["energyClass"] ? EnergyClassDto.fromJS(_data["energyClass"]) : <any>undefined;
            this.contructionYear = _data["contructionYear"];
            this.landArea = _data["landArea"];
            this.lounges = _data["lounges"];
            this.monthlyShared = _data["monthlyShared"];
            this.distanceFromSea = _data["distanceFromSea"];
            this.yearOfRenovation = _data["yearOfRenovation"];
            this.buildingCoefficient = _data["buildingCoefficient"];
            this.systemCode = _data["systemCode"];
            this.propertyCode = _data["propertyCode"];
            this.availableFrom = _data["availableFrom"] ? new Date(_data["availableFrom"].toString()) : <any>undefined;
            this.publicationOfAdvert = _data["publicationOfAdvert"] ? new Date(_data["publicationOfAdvert"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
            this.classified = _data["classified"] ? ClassifiedDto.fromJS(_data["classified"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ClassifiedCharacteristicsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClassifiedCharacteristicsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["characteristicsID"] = this.characteristicsID;
        data["price"] = this.price;
        data["pricePerTm"] = this.pricePerTm;
        data["areaTm"] = this.areaTm;
        data["landAreaTm"] = this.landAreaTm;
        data["levels"] = this.levels;
        data["square"] = this.square;
        data["region"] = this.region;
        data["cuisines"] = this.cuisines;
        data["bathrooms"] = this.bathrooms;
        data["bedrooms"] = this.bedrooms;
        data["heatingTypeID"] = this.heatingTypeID;
        data["heatingType"] = this.heatingType ? this.heatingType.toJSON() : <any>undefined;
        data["heatingSystemID"] = this.heatingSystemID;
        data["heatingSystem"] = this.heatingSystem ? this.heatingSystem.toJSON() : <any>undefined;
        data["energyClassID"] = this.energyClassID;
        data["energyClass"] = this.energyClass ? this.energyClass.toJSON() : <any>undefined;
        data["contructionYear"] = this.contructionYear;
        data["landArea"] = this.landArea;
        data["lounges"] = this.lounges;
        data["monthlyShared"] = this.monthlyShared;
        data["distanceFromSea"] = this.distanceFromSea;
        data["yearOfRenovation"] = this.yearOfRenovation;
        data["buildingCoefficient"] = this.buildingCoefficient;
        data["systemCode"] = this.systemCode;
        data["propertyCode"] = this.propertyCode;
        data["availableFrom"] = this.availableFrom ? this.availableFrom.toISOString() : <any>undefined;
        data["publicationOfAdvert"] = this.publicationOfAdvert ? this.publicationOfAdvert.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        data["classified"] = this.classified ? this.classified.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IClassifiedCharacteristicsDto extends IAuditableEntity {
    characteristicsID?: number;
    price?: number;
    pricePerTm?: number;
    areaTm?: number;
    landAreaTm?: number;
    levels?: number;
    square?: number;
    region?: string | undefined;
    cuisines?: number;
    bathrooms?: number;
    bedrooms?: number;
    heatingTypeID?: number;
    heatingType?: HeatingTypeDto | undefined;
    heatingSystemID?: number;
    heatingSystem?: HeatingSystemDto | undefined;
    energyClassID?: number;
    energyClass?: EnergyClassDto | undefined;
    contructionYear?: number;
    landArea?: number;
    lounges?: number;
    monthlyShared?: number;
    distanceFromSea?: number;
    yearOfRenovation?: number;
    buildingCoefficient?: number;
    systemCode?: string | undefined;
    propertyCode?: string | undefined;
    availableFrom?: Date | undefined;
    publicationOfAdvert?: Date | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classified?: ClassifiedDto | undefined;
}

export class HeatingTypeDto implements IHeatingTypeDto {
    heatingTypeID?: number;
    heatingTypeValue?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classifiedCharacteristics?: ClassifiedCharacteristics[] | undefined;

    constructor(data?: IHeatingTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.heatingTypeID = _data["heatingTypeID"];
            this.heatingTypeValue = _data["heatingTypeValue"];
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["classifiedCharacteristics"])) {
                this.classifiedCharacteristics = [] as any;
                for (let item of _data["classifiedCharacteristics"])
                    this.classifiedCharacteristics!.push(ClassifiedCharacteristics.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HeatingTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new HeatingTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["heatingTypeID"] = this.heatingTypeID;
        data["heatingTypeValue"] = this.heatingTypeValue;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.classifiedCharacteristics)) {
            data["classifiedCharacteristics"] = [];
            for (let item of this.classifiedCharacteristics)
                data["classifiedCharacteristics"].push(item.toJSON());
        }
        return data;
    }
}

export interface IHeatingTypeDto {
    heatingTypeID?: number;
    heatingTypeValue?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classifiedCharacteristics?: ClassifiedCharacteristics[] | undefined;
}

export class ClassifiedCharacteristics extends AuditableEntity implements IClassifiedCharacteristics {
    characteristicsID?: number;
    price?: number;
    pricePerTm?: number;
    areaTm?: number;
    landAreaTm?: number;
    levels?: number;
    square?: number;
    region?: string | undefined;
    cuisines?: number;
    bathrooms?: number;
    bedrooms?: number;
    heatingTypeID?: number;
    heatingType?: HeatingType | undefined;
    heatingSystemID?: number;
    heatingSystem?: HeatingSystem | undefined;
    energyClassID?: number;
    energyClass?: EnergyClass | undefined;
    contructionYear?: number;
    landArea?: number;
    lounges?: number;
    monthlyShared?: number;
    distanceFromSea?: number;
    yearOfRenovation?: number;
    buildingCoefficient?: number;
    systemCode?: string | undefined;
    propertyCode?: string | undefined;
    availableFrom?: Date | undefined;
    publicationOfAdvert?: Date | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classified?: Classified | undefined;

    constructor(data?: IClassifiedCharacteristics) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.characteristicsID = _data["characteristicsID"];
            this.price = _data["price"];
            this.pricePerTm = _data["pricePerTm"];
            this.areaTm = _data["areaTm"];
            this.landAreaTm = _data["landAreaTm"];
            this.levels = _data["levels"];
            this.square = _data["square"];
            this.region = _data["region"];
            this.cuisines = _data["cuisines"];
            this.bathrooms = _data["bathrooms"];
            this.bedrooms = _data["bedrooms"];
            this.heatingTypeID = _data["heatingTypeID"];
            this.heatingType = _data["heatingType"] ? HeatingType.fromJS(_data["heatingType"]) : <any>undefined;
            this.heatingSystemID = _data["heatingSystemID"];
            this.heatingSystem = _data["heatingSystem"] ? HeatingSystem.fromJS(_data["heatingSystem"]) : <any>undefined;
            this.energyClassID = _data["energyClassID"];
            this.energyClass = _data["energyClass"] ? EnergyClass.fromJS(_data["energyClass"]) : <any>undefined;
            this.contructionYear = _data["contructionYear"];
            this.landArea = _data["landArea"];
            this.lounges = _data["lounges"];
            this.monthlyShared = _data["monthlyShared"];
            this.distanceFromSea = _data["distanceFromSea"];
            this.yearOfRenovation = _data["yearOfRenovation"];
            this.buildingCoefficient = _data["buildingCoefficient"];
            this.systemCode = _data["systemCode"];
            this.propertyCode = _data["propertyCode"];
            this.availableFrom = _data["availableFrom"] ? new Date(_data["availableFrom"].toString()) : <any>undefined;
            this.publicationOfAdvert = _data["publicationOfAdvert"] ? new Date(_data["publicationOfAdvert"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
            this.classified = _data["classified"] ? Classified.fromJS(_data["classified"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ClassifiedCharacteristics {
        data = typeof data === 'object' ? data : {};
        let result = new ClassifiedCharacteristics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["characteristicsID"] = this.characteristicsID;
        data["price"] = this.price;
        data["pricePerTm"] = this.pricePerTm;
        data["areaTm"] = this.areaTm;
        data["landAreaTm"] = this.landAreaTm;
        data["levels"] = this.levels;
        data["square"] = this.square;
        data["region"] = this.region;
        data["cuisines"] = this.cuisines;
        data["bathrooms"] = this.bathrooms;
        data["bedrooms"] = this.bedrooms;
        data["heatingTypeID"] = this.heatingTypeID;
        data["heatingType"] = this.heatingType ? this.heatingType.toJSON() : <any>undefined;
        data["heatingSystemID"] = this.heatingSystemID;
        data["heatingSystem"] = this.heatingSystem ? this.heatingSystem.toJSON() : <any>undefined;
        data["energyClassID"] = this.energyClassID;
        data["energyClass"] = this.energyClass ? this.energyClass.toJSON() : <any>undefined;
        data["contructionYear"] = this.contructionYear;
        data["landArea"] = this.landArea;
        data["lounges"] = this.lounges;
        data["monthlyShared"] = this.monthlyShared;
        data["distanceFromSea"] = this.distanceFromSea;
        data["yearOfRenovation"] = this.yearOfRenovation;
        data["buildingCoefficient"] = this.buildingCoefficient;
        data["systemCode"] = this.systemCode;
        data["propertyCode"] = this.propertyCode;
        data["availableFrom"] = this.availableFrom ? this.availableFrom.toISOString() : <any>undefined;
        data["publicationOfAdvert"] = this.publicationOfAdvert ? this.publicationOfAdvert.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        data["classified"] = this.classified ? this.classified.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IClassifiedCharacteristics extends IAuditableEntity {
    characteristicsID?: number;
    price?: number;
    pricePerTm?: number;
    areaTm?: number;
    landAreaTm?: number;
    levels?: number;
    square?: number;
    region?: string | undefined;
    cuisines?: number;
    bathrooms?: number;
    bedrooms?: number;
    heatingTypeID?: number;
    heatingType?: HeatingType | undefined;
    heatingSystemID?: number;
    heatingSystem?: HeatingSystem | undefined;
    energyClassID?: number;
    energyClass?: EnergyClass | undefined;
    contructionYear?: number;
    landArea?: number;
    lounges?: number;
    monthlyShared?: number;
    distanceFromSea?: number;
    yearOfRenovation?: number;
    buildingCoefficient?: number;
    systemCode?: string | undefined;
    propertyCode?: string | undefined;
    availableFrom?: Date | undefined;
    publicationOfAdvert?: Date | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classified?: Classified | undefined;
}

export class HeatingType extends AuditableEntity implements IHeatingType {
    heatingTypeID?: number;
    heatingTypeValue?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classifiedCharacteristics?: ClassifiedCharacteristics[] | undefined;

    constructor(data?: IHeatingType) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.heatingTypeID = _data["heatingTypeID"];
            this.heatingTypeValue = _data["heatingTypeValue"];
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["classifiedCharacteristics"])) {
                this.classifiedCharacteristics = [] as any;
                for (let item of _data["classifiedCharacteristics"])
                    this.classifiedCharacteristics!.push(ClassifiedCharacteristics.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HeatingType {
        data = typeof data === 'object' ? data : {};
        let result = new HeatingType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["heatingTypeID"] = this.heatingTypeID;
        data["heatingTypeValue"] = this.heatingTypeValue;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.classifiedCharacteristics)) {
            data["classifiedCharacteristics"] = [];
            for (let item of this.classifiedCharacteristics)
                data["classifiedCharacteristics"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IHeatingType extends IAuditableEntity {
    heatingTypeID?: number;
    heatingTypeValue?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classifiedCharacteristics?: ClassifiedCharacteristics[] | undefined;
}

export class HeatingSystem extends AuditableEntity implements IHeatingSystem {
    heatingSystemID?: number;
    heatingSystemValue?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classifiedCharacteristics?: ClassifiedCharacteristics[] | undefined;

    constructor(data?: IHeatingSystem) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.heatingSystemID = _data["heatingSystemID"];
            this.heatingSystemValue = _data["heatingSystemValue"];
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["classifiedCharacteristics"])) {
                this.classifiedCharacteristics = [] as any;
                for (let item of _data["classifiedCharacteristics"])
                    this.classifiedCharacteristics!.push(ClassifiedCharacteristics.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HeatingSystem {
        data = typeof data === 'object' ? data : {};
        let result = new HeatingSystem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["heatingSystemID"] = this.heatingSystemID;
        data["heatingSystemValue"] = this.heatingSystemValue;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.classifiedCharacteristics)) {
            data["classifiedCharacteristics"] = [];
            for (let item of this.classifiedCharacteristics)
                data["classifiedCharacteristics"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IHeatingSystem extends IAuditableEntity {
    heatingSystemID?: number;
    heatingSystemValue?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classifiedCharacteristics?: ClassifiedCharacteristics[] | undefined;
}

export class EnergyClass extends AuditableEntity implements IEnergyClass {
    energyClassID?: number;
    energyClassValue?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classifiedCharacteristics?: ClassifiedCharacteristics[] | undefined;

    constructor(data?: IEnergyClass) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.energyClassID = _data["energyClassID"];
            this.energyClassValue = _data["energyClassValue"];
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["classifiedCharacteristics"])) {
                this.classifiedCharacteristics = [] as any;
                for (let item of _data["classifiedCharacteristics"])
                    this.classifiedCharacteristics!.push(ClassifiedCharacteristics.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EnergyClass {
        data = typeof data === 'object' ? data : {};
        let result = new EnergyClass();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["energyClassID"] = this.energyClassID;
        data["energyClassValue"] = this.energyClassValue;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.classifiedCharacteristics)) {
            data["classifiedCharacteristics"] = [];
            for (let item of this.classifiedCharacteristics)
                data["classifiedCharacteristics"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IEnergyClass extends IAuditableEntity {
    energyClassID?: number;
    energyClassValue?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classifiedCharacteristics?: ClassifiedCharacteristics[] | undefined;
}

export class Classified extends AuditableEntity implements IClassified {
    classifiedID?: number;
    purposeID?: number;
    classifiedPurpose?: ClassifiedPurpose | undefined;
    typeID?: number;
    classifiedType?: ClassifiedType | undefined;
    googleMapPlaceID?: number;
    googleMapPlace?: GoogleMapPlace | undefined;
    advertiserInfoID?: number;
    advertiserInfo?: AdvertiserInfo | undefined;
    suitableForID?: number;
    suitableFor?: SuitableFor | undefined;
    classifiedConstructionID?: number;
    classifiedConstruction?: ClassifiedConstruction | undefined;
    exteriorFeaturesID?: number;
    exteriorFeature?: ExteriorFeature | undefined;
    interiorFeaturesID?: number;
    interiorFeature?: InteriorFeature | undefined;
    floorNoID?: number;
    floorNo?: FloorNo | undefined;
    characteristicsID?: number;
    classifiedCharacteristics?: ClassifiedCharacteristics | undefined;
    photos?: Photos[] | undefined;
    classifiedTitle?: string | undefined;
    classifiedDesription?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;

    constructor(data?: IClassified) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.classifiedID = _data["classifiedID"];
            this.purposeID = _data["purposeID"];
            this.classifiedPurpose = _data["classifiedPurpose"] ? ClassifiedPurpose.fromJS(_data["classifiedPurpose"]) : <any>undefined;
            this.typeID = _data["typeID"];
            this.classifiedType = _data["classifiedType"] ? ClassifiedType.fromJS(_data["classifiedType"]) : <any>undefined;
            this.googleMapPlaceID = _data["googleMapPlaceID"];
            this.googleMapPlace = _data["googleMapPlace"] ? GoogleMapPlace.fromJS(_data["googleMapPlace"]) : <any>undefined;
            this.advertiserInfoID = _data["advertiserInfoID"];
            this.advertiserInfo = _data["advertiserInfo"] ? AdvertiserInfo.fromJS(_data["advertiserInfo"]) : <any>undefined;
            this.suitableForID = _data["suitableForID"];
            this.suitableFor = _data["suitableFor"] ? SuitableFor.fromJS(_data["suitableFor"]) : <any>undefined;
            this.classifiedConstructionID = _data["classifiedConstructionID"];
            this.classifiedConstruction = _data["classifiedConstruction"] ? ClassifiedConstruction.fromJS(_data["classifiedConstruction"]) : <any>undefined;
            this.exteriorFeaturesID = _data["exteriorFeaturesID"];
            this.exteriorFeature = _data["exteriorFeature"] ? ExteriorFeature.fromJS(_data["exteriorFeature"]) : <any>undefined;
            this.interiorFeaturesID = _data["interiorFeaturesID"];
            this.interiorFeature = _data["interiorFeature"] ? InteriorFeature.fromJS(_data["interiorFeature"]) : <any>undefined;
            this.floorNoID = _data["floorNoID"];
            this.floorNo = _data["floorNo"] ? FloorNo.fromJS(_data["floorNo"]) : <any>undefined;
            this.characteristicsID = _data["characteristicsID"];
            this.classifiedCharacteristics = _data["classifiedCharacteristics"] ? ClassifiedCharacteristics.fromJS(_data["classifiedCharacteristics"]) : <any>undefined;
            if (Array.isArray(_data["photos"])) {
                this.photos = [] as any;
                for (let item of _data["photos"])
                    this.photos!.push(Photos.fromJS(item));
            }
            this.classifiedTitle = _data["classifiedTitle"];
            this.classifiedDesription = _data["classifiedDesription"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
        }
    }

    static fromJS(data: any): Classified {
        data = typeof data === 'object' ? data : {};
        let result = new Classified();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classifiedID"] = this.classifiedID;
        data["purposeID"] = this.purposeID;
        data["classifiedPurpose"] = this.classifiedPurpose ? this.classifiedPurpose.toJSON() : <any>undefined;
        data["typeID"] = this.typeID;
        data["classifiedType"] = this.classifiedType ? this.classifiedType.toJSON() : <any>undefined;
        data["googleMapPlaceID"] = this.googleMapPlaceID;
        data["googleMapPlace"] = this.googleMapPlace ? this.googleMapPlace.toJSON() : <any>undefined;
        data["advertiserInfoID"] = this.advertiserInfoID;
        data["advertiserInfo"] = this.advertiserInfo ? this.advertiserInfo.toJSON() : <any>undefined;
        data["suitableForID"] = this.suitableForID;
        data["suitableFor"] = this.suitableFor ? this.suitableFor.toJSON() : <any>undefined;
        data["classifiedConstructionID"] = this.classifiedConstructionID;
        data["classifiedConstruction"] = this.classifiedConstruction ? this.classifiedConstruction.toJSON() : <any>undefined;
        data["exteriorFeaturesID"] = this.exteriorFeaturesID;
        data["exteriorFeature"] = this.exteriorFeature ? this.exteriorFeature.toJSON() : <any>undefined;
        data["interiorFeaturesID"] = this.interiorFeaturesID;
        data["interiorFeature"] = this.interiorFeature ? this.interiorFeature.toJSON() : <any>undefined;
        data["floorNoID"] = this.floorNoID;
        data["floorNo"] = this.floorNo ? this.floorNo.toJSON() : <any>undefined;
        data["characteristicsID"] = this.characteristicsID;
        data["classifiedCharacteristics"] = this.classifiedCharacteristics ? this.classifiedCharacteristics.toJSON() : <any>undefined;
        if (Array.isArray(this.photos)) {
            data["photos"] = [];
            for (let item of this.photos)
                data["photos"].push(item.toJSON());
        }
        data["classifiedTitle"] = this.classifiedTitle;
        data["classifiedDesription"] = this.classifiedDesription;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        super.toJSON(data);
        return data;
    }
}

export interface IClassified extends IAuditableEntity {
    classifiedID?: number;
    purposeID?: number;
    classifiedPurpose?: ClassifiedPurpose | undefined;
    typeID?: number;
    classifiedType?: ClassifiedType | undefined;
    googleMapPlaceID?: number;
    googleMapPlace?: GoogleMapPlace | undefined;
    advertiserInfoID?: number;
    advertiserInfo?: AdvertiserInfo | undefined;
    suitableForID?: number;
    suitableFor?: SuitableFor | undefined;
    classifiedConstructionID?: number;
    classifiedConstruction?: ClassifiedConstruction | undefined;
    exteriorFeaturesID?: number;
    exteriorFeature?: ExteriorFeature | undefined;
    interiorFeaturesID?: number;
    interiorFeature?: InteriorFeature | undefined;
    floorNoID?: number;
    floorNo?: FloorNo | undefined;
    characteristicsID?: number;
    classifiedCharacteristics?: ClassifiedCharacteristics | undefined;
    photos?: Photos[] | undefined;
    classifiedTitle?: string | undefined;
    classifiedDesription?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
}

export class ClassifiedPurpose extends AuditableEntity implements IClassifiedPurpose {
    purposeID?: number;
    title?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classifieds?: Classified[] | undefined;

    constructor(data?: IClassifiedPurpose) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.purposeID = _data["purposeID"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["classifieds"])) {
                this.classifieds = [] as any;
                for (let item of _data["classifieds"])
                    this.classifieds!.push(Classified.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClassifiedPurpose {
        data = typeof data === 'object' ? data : {};
        let result = new ClassifiedPurpose();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purposeID"] = this.purposeID;
        data["title"] = this.title;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.classifieds)) {
            data["classifieds"] = [];
            for (let item of this.classifieds)
                data["classifieds"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IClassifiedPurpose extends IAuditableEntity {
    purposeID?: number;
    title?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classifieds?: Classified[] | undefined;
}

export class ClassifiedType extends AuditableEntity implements IClassifiedType {
    typeID?: number;
    title?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classifieds?: Classified[] | undefined;

    constructor(data?: IClassifiedType) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.typeID = _data["typeID"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["classifieds"])) {
                this.classifieds = [] as any;
                for (let item of _data["classifieds"])
                    this.classifieds!.push(Classified.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClassifiedType {
        data = typeof data === 'object' ? data : {};
        let result = new ClassifiedType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeID"] = this.typeID;
        data["title"] = this.title;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.classifieds)) {
            data["classifieds"] = [];
            for (let item of this.classifieds)
                data["classifieds"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IClassifiedType extends IAuditableEntity {
    typeID?: number;
    title?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classifieds?: Classified[] | undefined;
}

export class GoogleMapPlace extends AuditableEntity implements IGoogleMapPlace {
    googleMapPlaceID?: number;
    area?: string | undefined;
    latitude?: string | undefined;
    longitude?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classified?: Classified | undefined;

    constructor(data?: IGoogleMapPlace) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.googleMapPlaceID = _data["googleMapPlaceID"];
            this.area = _data["area"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
            this.classified = _data["classified"] ? Classified.fromJS(_data["classified"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GoogleMapPlace {
        data = typeof data === 'object' ? data : {};
        let result = new GoogleMapPlace();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["googleMapPlaceID"] = this.googleMapPlaceID;
        data["area"] = this.area;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        data["classified"] = this.classified ? this.classified.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IGoogleMapPlace extends IAuditableEntity {
    googleMapPlaceID?: number;
    area?: string | undefined;
    latitude?: string | undefined;
    longitude?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classified?: Classified | undefined;
}

export class AdvertiserInfo extends AuditableEntity implements IAdvertiserInfo {
    advertiserInfoID?: number;
    code?: string | undefined;
    name?: string | undefined;
    address?: string | undefined;
    responsible?: string | undefined;
    telephone?: string | undefined;
    email?: string | undefined;
    website?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classifieds?: Classified[] | undefined;

    constructor(data?: IAdvertiserInfo) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.advertiserInfoID = _data["advertiserInfoID"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.address = _data["address"];
            this.responsible = _data["responsible"];
            this.telephone = _data["telephone"];
            this.email = _data["email"];
            this.website = _data["website"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["classifieds"])) {
                this.classifieds = [] as any;
                for (let item of _data["classifieds"])
                    this.classifieds!.push(Classified.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdvertiserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new AdvertiserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["advertiserInfoID"] = this.advertiserInfoID;
        data["code"] = this.code;
        data["name"] = this.name;
        data["address"] = this.address;
        data["responsible"] = this.responsible;
        data["telephone"] = this.telephone;
        data["email"] = this.email;
        data["website"] = this.website;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.classifieds)) {
            data["classifieds"] = [];
            for (let item of this.classifieds)
                data["classifieds"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IAdvertiserInfo extends IAuditableEntity {
    advertiserInfoID?: number;
    code?: string | undefined;
    name?: string | undefined;
    address?: string | undefined;
    responsible?: string | undefined;
    telephone?: string | undefined;
    email?: string | undefined;
    website?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classifieds?: Classified[] | undefined;
}

export class SuitableFor extends AuditableEntity implements ISuitableFor {
    suitableForID?: number;
    studentUse?: boolean;
    holidayHomeUse?: boolean;
    professionalUse?: boolean;
    investmentUse?: boolean;
    touristRentalUse?: boolean;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classified?: Classified | undefined;

    constructor(data?: ISuitableFor) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.suitableForID = _data["suitableForID"];
            this.studentUse = _data["studentUse"];
            this.holidayHomeUse = _data["holidayHomeUse"];
            this.professionalUse = _data["professionalUse"];
            this.investmentUse = _data["investmentUse"];
            this.touristRentalUse = _data["touristRentalUse"];
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
            this.classified = _data["classified"] ? Classified.fromJS(_data["classified"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SuitableFor {
        data = typeof data === 'object' ? data : {};
        let result = new SuitableFor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["suitableForID"] = this.suitableForID;
        data["studentUse"] = this.studentUse;
        data["holidayHomeUse"] = this.holidayHomeUse;
        data["professionalUse"] = this.professionalUse;
        data["investmentUse"] = this.investmentUse;
        data["touristRentalUse"] = this.touristRentalUse;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        data["classified"] = this.classified ? this.classified.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ISuitableFor extends IAuditableEntity {
    suitableForID?: number;
    studentUse?: boolean;
    holidayHomeUse?: boolean;
    professionalUse?: boolean;
    investmentUse?: boolean;
    touristRentalUse?: boolean;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classified?: Classified | undefined;
}

export class ClassifiedConstruction extends AuditableEntity implements IClassifiedConstruction {
    classifiedConstructionID?: number;
    pentHouse?: boolean;
    newlyBuilt?: boolean;
    renovated?: boolean;
    needsToBeRenovated?: boolean;
    neoClassical?: boolean;
    preserved?: boolean;
    incomplete?: boolean;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classified?: Classified | undefined;

    constructor(data?: IClassifiedConstruction) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.classifiedConstructionID = _data["classifiedConstructionID"];
            this.pentHouse = _data["pentHouse"];
            this.newlyBuilt = _data["newlyBuilt"];
            this.renovated = _data["renovated"];
            this.needsToBeRenovated = _data["needsToBeRenovated"];
            this.neoClassical = _data["neoClassical"];
            this.preserved = _data["preserved"];
            this.incomplete = _data["incomplete"];
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
            this.classified = _data["classified"] ? Classified.fromJS(_data["classified"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ClassifiedConstruction {
        data = typeof data === 'object' ? data : {};
        let result = new ClassifiedConstruction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classifiedConstructionID"] = this.classifiedConstructionID;
        data["pentHouse"] = this.pentHouse;
        data["newlyBuilt"] = this.newlyBuilt;
        data["renovated"] = this.renovated;
        data["needsToBeRenovated"] = this.needsToBeRenovated;
        data["neoClassical"] = this.neoClassical;
        data["preserved"] = this.preserved;
        data["incomplete"] = this.incomplete;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        data["classified"] = this.classified ? this.classified.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IClassifiedConstruction extends IAuditableEntity {
    classifiedConstructionID?: number;
    pentHouse?: boolean;
    newlyBuilt?: boolean;
    renovated?: boolean;
    needsToBeRenovated?: boolean;
    neoClassical?: boolean;
    preserved?: boolean;
    incomplete?: boolean;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classified?: Classified | undefined;
}

export class ExteriorFeature extends AuditableEntity implements IExteriorFeature {
    exteriorFeaturesID?: number;
    propertyView?: boolean;
    facade?: boolean;
    orientation?: string | undefined;
    accessFrom?: string | undefined;
    residentialZone?: boolean;
    parkingSpot?: boolean;
    awnings?: boolean;
    garden?: boolean;
    disabledAccess?: boolean;
    pool?: boolean;
    corner?: boolean;
    veranda?: boolean;
    showcaseGlassLength?: number | undefined;
    unloadingRamp?: boolean | undefined;
    withinCityPlan?: boolean;
    structureFactor?: number;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classified?: Classified | undefined;

    constructor(data?: IExteriorFeature) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.exteriorFeaturesID = _data["exteriorFeaturesID"];
            this.propertyView = _data["propertyView"];
            this.facade = _data["facade"];
            this.orientation = _data["orientation"];
            this.accessFrom = _data["accessFrom"];
            this.residentialZone = _data["residentialZone"];
            this.parkingSpot = _data["parkingSpot"];
            this.awnings = _data["awnings"];
            this.garden = _data["garden"];
            this.disabledAccess = _data["disabledAccess"];
            this.pool = _data["pool"];
            this.corner = _data["corner"];
            this.veranda = _data["veranda"];
            this.showcaseGlassLength = _data["showcaseGlassLength"];
            this.unloadingRamp = _data["unloadingRamp"];
            this.withinCityPlan = _data["withinCityPlan"];
            this.structureFactor = _data["structureFactor"];
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
            this.classified = _data["classified"] ? Classified.fromJS(_data["classified"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExteriorFeature {
        data = typeof data === 'object' ? data : {};
        let result = new ExteriorFeature();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exteriorFeaturesID"] = this.exteriorFeaturesID;
        data["propertyView"] = this.propertyView;
        data["facade"] = this.facade;
        data["orientation"] = this.orientation;
        data["accessFrom"] = this.accessFrom;
        data["residentialZone"] = this.residentialZone;
        data["parkingSpot"] = this.parkingSpot;
        data["awnings"] = this.awnings;
        data["garden"] = this.garden;
        data["disabledAccess"] = this.disabledAccess;
        data["pool"] = this.pool;
        data["corner"] = this.corner;
        data["veranda"] = this.veranda;
        data["showcaseGlassLength"] = this.showcaseGlassLength;
        data["unloadingRamp"] = this.unloadingRamp;
        data["withinCityPlan"] = this.withinCityPlan;
        data["structureFactor"] = this.structureFactor;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        data["classified"] = this.classified ? this.classified.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IExteriorFeature extends IAuditableEntity {
    exteriorFeaturesID?: number;
    propertyView?: boolean;
    facade?: boolean;
    orientation?: string | undefined;
    accessFrom?: string | undefined;
    residentialZone?: boolean;
    parkingSpot?: boolean;
    awnings?: boolean;
    garden?: boolean;
    disabledAccess?: boolean;
    pool?: boolean;
    corner?: boolean;
    veranda?: boolean;
    showcaseGlassLength?: number | undefined;
    unloadingRamp?: boolean | undefined;
    withinCityPlan?: boolean;
    structureFactor?: number;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classified?: Classified | undefined;
}

export class InteriorFeature extends AuditableEntity implements IInteriorFeature {
    interiorFeaturesID?: number;
    elevator?: boolean;
    internalStaircase?: boolean;
    airConditioning?: boolean;
    warehouse?: boolean;
    floorTypeID?: number;
    floorType?: FloorType | undefined;
    petsWelcome?: boolean;
    securityDoor?: boolean;
    frameTypeID?: number;
    frameType?: FrameType | undefined;
    powerTypeID?: number;
    powerType?: PowerType | undefined;
    doubleGlazing?: boolean;
    furnished?: boolean;
    fireplace?: boolean;
    underfloorHeating?: boolean;
    solarHeating?: boolean;
    nightCurrent?: boolean;
    garret?: boolean;
    playroom?: boolean;
    satelliteAntenna?: boolean;
    alarm?: boolean;
    doorScreens?: boolean;
    airy?: boolean;
    painted?: boolean;
    withEquipment?: boolean;
    cableTV?: boolean;
    wiring?: boolean;
    loadingUnloadingElevator?: boolean;
    suspendedCeiling?: boolean;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classified?: Classified | undefined;

    constructor(data?: IInteriorFeature) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.interiorFeaturesID = _data["interiorFeaturesID"];
            this.elevator = _data["elevator"];
            this.internalStaircase = _data["internalStaircase"];
            this.airConditioning = _data["airConditioning"];
            this.warehouse = _data["warehouse"];
            this.floorTypeID = _data["floorTypeID"];
            this.floorType = _data["floorType"] ? FloorType.fromJS(_data["floorType"]) : <any>undefined;
            this.petsWelcome = _data["petsWelcome"];
            this.securityDoor = _data["securityDoor"];
            this.frameTypeID = _data["frameTypeID"];
            this.frameType = _data["frameType"] ? FrameType.fromJS(_data["frameType"]) : <any>undefined;
            this.powerTypeID = _data["powerTypeID"];
            this.powerType = _data["powerType"] ? PowerType.fromJS(_data["powerType"]) : <any>undefined;
            this.doubleGlazing = _data["doubleGlazing"];
            this.furnished = _data["furnished"];
            this.fireplace = _data["fireplace"];
            this.underfloorHeating = _data["underfloorHeating"];
            this.solarHeating = _data["solarHeating"];
            this.nightCurrent = _data["nightCurrent"];
            this.garret = _data["garret"];
            this.playroom = _data["playroom"];
            this.satelliteAntenna = _data["satelliteAntenna"];
            this.alarm = _data["alarm"];
            this.doorScreens = _data["doorScreens"];
            this.airy = _data["airy"];
            this.painted = _data["painted"];
            this.withEquipment = _data["withEquipment"];
            this.cableTV = _data["cableTV"];
            this.wiring = _data["wiring"];
            this.loadingUnloadingElevator = _data["loadingUnloadingElevator"];
            this.suspendedCeiling = _data["suspendedCeiling"];
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
            this.classified = _data["classified"] ? Classified.fromJS(_data["classified"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InteriorFeature {
        data = typeof data === 'object' ? data : {};
        let result = new InteriorFeature();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["interiorFeaturesID"] = this.interiorFeaturesID;
        data["elevator"] = this.elevator;
        data["internalStaircase"] = this.internalStaircase;
        data["airConditioning"] = this.airConditioning;
        data["warehouse"] = this.warehouse;
        data["floorTypeID"] = this.floorTypeID;
        data["floorType"] = this.floorType ? this.floorType.toJSON() : <any>undefined;
        data["petsWelcome"] = this.petsWelcome;
        data["securityDoor"] = this.securityDoor;
        data["frameTypeID"] = this.frameTypeID;
        data["frameType"] = this.frameType ? this.frameType.toJSON() : <any>undefined;
        data["powerTypeID"] = this.powerTypeID;
        data["powerType"] = this.powerType ? this.powerType.toJSON() : <any>undefined;
        data["doubleGlazing"] = this.doubleGlazing;
        data["furnished"] = this.furnished;
        data["fireplace"] = this.fireplace;
        data["underfloorHeating"] = this.underfloorHeating;
        data["solarHeating"] = this.solarHeating;
        data["nightCurrent"] = this.nightCurrent;
        data["garret"] = this.garret;
        data["playroom"] = this.playroom;
        data["satelliteAntenna"] = this.satelliteAntenna;
        data["alarm"] = this.alarm;
        data["doorScreens"] = this.doorScreens;
        data["airy"] = this.airy;
        data["painted"] = this.painted;
        data["withEquipment"] = this.withEquipment;
        data["cableTV"] = this.cableTV;
        data["wiring"] = this.wiring;
        data["loadingUnloadingElevator"] = this.loadingUnloadingElevator;
        data["suspendedCeiling"] = this.suspendedCeiling;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        data["classified"] = this.classified ? this.classified.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IInteriorFeature extends IAuditableEntity {
    interiorFeaturesID?: number;
    elevator?: boolean;
    internalStaircase?: boolean;
    airConditioning?: boolean;
    warehouse?: boolean;
    floorTypeID?: number;
    floorType?: FloorType | undefined;
    petsWelcome?: boolean;
    securityDoor?: boolean;
    frameTypeID?: number;
    frameType?: FrameType | undefined;
    powerTypeID?: number;
    powerType?: PowerType | undefined;
    doubleGlazing?: boolean;
    furnished?: boolean;
    fireplace?: boolean;
    underfloorHeating?: boolean;
    solarHeating?: boolean;
    nightCurrent?: boolean;
    garret?: boolean;
    playroom?: boolean;
    satelliteAntenna?: boolean;
    alarm?: boolean;
    doorScreens?: boolean;
    airy?: boolean;
    painted?: boolean;
    withEquipment?: boolean;
    cableTV?: boolean;
    wiring?: boolean;
    loadingUnloadingElevator?: boolean;
    suspendedCeiling?: boolean;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classified?: Classified | undefined;
}

export class FloorType extends AuditableEntity implements IFloorType {
    floorTypeID?: number;
    title?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    interiorFeatures?: InteriorFeature[] | undefined;

    constructor(data?: IFloorType) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.floorTypeID = _data["floorTypeID"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["interiorFeatures"])) {
                this.interiorFeatures = [] as any;
                for (let item of _data["interiorFeatures"])
                    this.interiorFeatures!.push(InteriorFeature.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FloorType {
        data = typeof data === 'object' ? data : {};
        let result = new FloorType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["floorTypeID"] = this.floorTypeID;
        data["title"] = this.title;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.interiorFeatures)) {
            data["interiorFeatures"] = [];
            for (let item of this.interiorFeatures)
                data["interiorFeatures"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IFloorType extends IAuditableEntity {
    floorTypeID?: number;
    title?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    interiorFeatures?: InteriorFeature[] | undefined;
}

export class FrameType extends AuditableEntity implements IFrameType {
    frameTypeID?: number;
    title?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    interiorFeatures?: InteriorFeature[] | undefined;

    constructor(data?: IFrameType) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.frameTypeID = _data["frameTypeID"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["interiorFeatures"])) {
                this.interiorFeatures = [] as any;
                for (let item of _data["interiorFeatures"])
                    this.interiorFeatures!.push(InteriorFeature.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FrameType {
        data = typeof data === 'object' ? data : {};
        let result = new FrameType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["frameTypeID"] = this.frameTypeID;
        data["title"] = this.title;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.interiorFeatures)) {
            data["interiorFeatures"] = [];
            for (let item of this.interiorFeatures)
                data["interiorFeatures"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IFrameType extends IAuditableEntity {
    frameTypeID?: number;
    title?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    interiorFeatures?: InteriorFeature[] | undefined;
}

export class PowerType extends AuditableEntity implements IPowerType {
    powerTypeID?: number;
    title?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    interiorFeatures?: InteriorFeature[] | undefined;

    constructor(data?: IPowerType) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.powerTypeID = _data["powerTypeID"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["interiorFeatures"])) {
                this.interiorFeatures = [] as any;
                for (let item of _data["interiorFeatures"])
                    this.interiorFeatures!.push(InteriorFeature.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PowerType {
        data = typeof data === 'object' ? data : {};
        let result = new PowerType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["powerTypeID"] = this.powerTypeID;
        data["title"] = this.title;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.interiorFeatures)) {
            data["interiorFeatures"] = [];
            for (let item of this.interiorFeatures)
                data["interiorFeatures"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPowerType extends IAuditableEntity {
    powerTypeID?: number;
    title?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    interiorFeatures?: InteriorFeature[] | undefined;
}

export class FloorNo extends AuditableEntity implements IFloorNo {
    floorNoID?: number;
    floorNoValue?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classifieds?: Classified[] | undefined;

    constructor(data?: IFloorNo) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.floorNoID = _data["floorNoID"];
            this.floorNoValue = _data["floorNoValue"];
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["classifieds"])) {
                this.classifieds = [] as any;
                for (let item of _data["classifieds"])
                    this.classifieds!.push(Classified.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FloorNo {
        data = typeof data === 'object' ? data : {};
        let result = new FloorNo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["floorNoID"] = this.floorNoID;
        data["floorNoValue"] = this.floorNoValue;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.classifieds)) {
            data["classifieds"] = [];
            for (let item of this.classifieds)
                data["classifieds"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IFloorNo extends IAuditableEntity {
    floorNoID?: number;
    floorNoValue?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classifieds?: Classified[] | undefined;
}

export class Photos extends AuditableEntity implements IPhotos {
    photoID?: number;
    classifiedID?: number;
    classified?: Classified | undefined;
    fileName?: string | undefined;
    fileSize?: number;
    fileContent?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;

    constructor(data?: IPhotos) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.photoID = _data["photoID"];
            this.classifiedID = _data["classifiedID"];
            this.classified = _data["classified"] ? Classified.fromJS(_data["classified"]) : <any>undefined;
            this.fileName = _data["fileName"];
            this.fileSize = _data["fileSize"];
            this.fileContent = _data["fileContent"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
        }
    }

    static fromJS(data: any): Photos {
        data = typeof data === 'object' ? data : {};
        let result = new Photos();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["photoID"] = this.photoID;
        data["classifiedID"] = this.classifiedID;
        data["classified"] = this.classified ? this.classified.toJSON() : <any>undefined;
        data["fileName"] = this.fileName;
        data["fileSize"] = this.fileSize;
        data["fileContent"] = this.fileContent;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        super.toJSON(data);
        return data;
    }
}

export interface IPhotos extends IAuditableEntity {
    photoID?: number;
    classifiedID?: number;
    classified?: Classified | undefined;
    fileName?: string | undefined;
    fileSize?: number;
    fileContent?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
}

export class HeatingSystemDto extends AuditableEntity implements IHeatingSystemDto {
    heatingSystemID?: number;
    heatingSystemValue?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classifiedCharacteristics?: ClassifiedCharacteristicsDto[] | undefined;

    constructor(data?: IHeatingSystemDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.heatingSystemID = _data["heatingSystemID"];
            this.heatingSystemValue = _data["heatingSystemValue"];
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["classifiedCharacteristics"])) {
                this.classifiedCharacteristics = [] as any;
                for (let item of _data["classifiedCharacteristics"])
                    this.classifiedCharacteristics!.push(ClassifiedCharacteristicsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HeatingSystemDto {
        data = typeof data === 'object' ? data : {};
        let result = new HeatingSystemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["heatingSystemID"] = this.heatingSystemID;
        data["heatingSystemValue"] = this.heatingSystemValue;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.classifiedCharacteristics)) {
            data["classifiedCharacteristics"] = [];
            for (let item of this.classifiedCharacteristics)
                data["classifiedCharacteristics"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IHeatingSystemDto extends IAuditableEntity {
    heatingSystemID?: number;
    heatingSystemValue?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classifiedCharacteristics?: ClassifiedCharacteristicsDto[] | undefined;
}

export class EnergyClassDto extends AuditableEntity implements IEnergyClassDto {
    energyClassID?: number;
    energyClassValue?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classifiedCharacteristics?: ClassifiedCharacteristicsDto[] | undefined;

    constructor(data?: IEnergyClassDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.energyClassID = _data["energyClassID"];
            this.energyClassValue = _data["energyClassValue"];
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["classifiedCharacteristics"])) {
                this.classifiedCharacteristics = [] as any;
                for (let item of _data["classifiedCharacteristics"])
                    this.classifiedCharacteristics!.push(ClassifiedCharacteristicsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EnergyClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnergyClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["energyClassID"] = this.energyClassID;
        data["energyClassValue"] = this.energyClassValue;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.classifiedCharacteristics)) {
            data["classifiedCharacteristics"] = [];
            for (let item of this.classifiedCharacteristics)
                data["classifiedCharacteristics"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IEnergyClassDto extends IAuditableEntity {
    energyClassID?: number;
    energyClassValue?: string | undefined;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classifiedCharacteristics?: ClassifiedCharacteristicsDto[] | undefined;
}

export class PhotosDto implements IPhotosDto {
    photoID?: number;
    classifiedID?: number;
    classified?: ClassifiedDto | undefined;
    fileName?: string | undefined;
    fileSize?: number;
    fileContent?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;

    constructor(data?: IPhotosDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.photoID = _data["photoID"];
            this.classifiedID = _data["classifiedID"];
            this.classified = _data["classified"] ? ClassifiedDto.fromJS(_data["classified"]) : <any>undefined;
            this.fileName = _data["fileName"];
            this.fileSize = _data["fileSize"];
            this.fileContent = _data["fileContent"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
        }
    }

    static fromJS(data: any): PhotosDto {
        data = typeof data === 'object' ? data : {};
        let result = new PhotosDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["photoID"] = this.photoID;
        data["classifiedID"] = this.classifiedID;
        data["classified"] = this.classified ? this.classified.toJSON() : <any>undefined;
        data["fileName"] = this.fileName;
        data["fileSize"] = this.fileSize;
        data["fileContent"] = this.fileContent;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        return data;
    }
}

export interface IPhotosDto {
    photoID?: number;
    classifiedID?: number;
    classified?: ClassifiedDto | undefined;
    fileName?: string | undefined;
    fileSize?: number;
    fileContent?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
}

export class SlApiResponseOfAdvertiserInfoDtoAndObject implements ISlApiResponseOfAdvertiserInfoDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: AdvertiserInfoDto | undefined;
    metaData?: any | undefined;

    constructor(data?: ISlApiResponseOfAdvertiserInfoDtoAndObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(SlApiMessage.fromJS(item));
            }
            this.data = _data["data"] ? AdvertiserInfoDto.fromJS(_data["data"]) : <any>undefined;
            this.metaData = _data["metaData"];
        }
    }

    static fromJS(data: any): SlApiResponseOfAdvertiserInfoDtoAndObject {
        data = typeof data === 'object' ? data : {};
        let result = new SlApiResponseOfAdvertiserInfoDtoAndObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["metaData"] = this.metaData;
        return data;
    }
}

export interface ISlApiResponseOfAdvertiserInfoDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: AdvertiserInfoDto | undefined;
    metaData?: any | undefined;
}

export class SlApiResponseOfPaginatedListOfClassifiedCharacteristicsDtoAndObject implements ISlApiResponseOfPaginatedListOfClassifiedCharacteristicsDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: PaginatedListOfClassifiedCharacteristicsDto | undefined;
    metaData?: any | undefined;

    constructor(data?: ISlApiResponseOfPaginatedListOfClassifiedCharacteristicsDtoAndObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(SlApiMessage.fromJS(item));
            }
            this.data = _data["data"] ? PaginatedListOfClassifiedCharacteristicsDto.fromJS(_data["data"]) : <any>undefined;
            this.metaData = _data["metaData"];
        }
    }

    static fromJS(data: any): SlApiResponseOfPaginatedListOfClassifiedCharacteristicsDtoAndObject {
        data = typeof data === 'object' ? data : {};
        let result = new SlApiResponseOfPaginatedListOfClassifiedCharacteristicsDtoAndObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["metaData"] = this.metaData;
        return data;
    }
}

export interface ISlApiResponseOfPaginatedListOfClassifiedCharacteristicsDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: PaginatedListOfClassifiedCharacteristicsDto | undefined;
    metaData?: any | undefined;
}

export class PaginatedListOfClassifiedCharacteristicsDto implements IPaginatedListOfClassifiedCharacteristicsDto {
    items?: ClassifiedCharacteristicsDto[] | undefined;
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfClassifiedCharacteristicsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ClassifiedCharacteristicsDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfClassifiedCharacteristicsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfClassifiedCharacteristicsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfClassifiedCharacteristicsDto {
    items?: ClassifiedCharacteristicsDto[] | undefined;
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class SlApiResponseOfClassifiedCharacteristicsDtoAndObject implements ISlApiResponseOfClassifiedCharacteristicsDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: ClassifiedCharacteristicsDto | undefined;
    metaData?: any | undefined;

    constructor(data?: ISlApiResponseOfClassifiedCharacteristicsDtoAndObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(SlApiMessage.fromJS(item));
            }
            this.data = _data["data"] ? ClassifiedCharacteristicsDto.fromJS(_data["data"]) : <any>undefined;
            this.metaData = _data["metaData"];
        }
    }

    static fromJS(data: any): SlApiResponseOfClassifiedCharacteristicsDtoAndObject {
        data = typeof data === 'object' ? data : {};
        let result = new SlApiResponseOfClassifiedCharacteristicsDtoAndObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["metaData"] = this.metaData;
        return data;
    }
}

export interface ISlApiResponseOfClassifiedCharacteristicsDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: ClassifiedCharacteristicsDto | undefined;
    metaData?: any | undefined;
}

export class SlApiResponseOfPaginatedListOfClassifiedConstructionDtoAndObject implements ISlApiResponseOfPaginatedListOfClassifiedConstructionDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: PaginatedListOfClassifiedConstructionDto | undefined;
    metaData?: any | undefined;

    constructor(data?: ISlApiResponseOfPaginatedListOfClassifiedConstructionDtoAndObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(SlApiMessage.fromJS(item));
            }
            this.data = _data["data"] ? PaginatedListOfClassifiedConstructionDto.fromJS(_data["data"]) : <any>undefined;
            this.metaData = _data["metaData"];
        }
    }

    static fromJS(data: any): SlApiResponseOfPaginatedListOfClassifiedConstructionDtoAndObject {
        data = typeof data === 'object' ? data : {};
        let result = new SlApiResponseOfPaginatedListOfClassifiedConstructionDtoAndObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["metaData"] = this.metaData;
        return data;
    }
}

export interface ISlApiResponseOfPaginatedListOfClassifiedConstructionDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: PaginatedListOfClassifiedConstructionDto | undefined;
    metaData?: any | undefined;
}

export class PaginatedListOfClassifiedConstructionDto implements IPaginatedListOfClassifiedConstructionDto {
    items?: ClassifiedConstructionDto[] | undefined;
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfClassifiedConstructionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ClassifiedConstructionDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfClassifiedConstructionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfClassifiedConstructionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfClassifiedConstructionDto {
    items?: ClassifiedConstructionDto[] | undefined;
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ClassifiedConstructionDto extends AuditableEntity implements IClassifiedConstructionDto {
    classifiedConstructionID?: number;
    pentHouse?: boolean;
    newlyBuilt?: boolean;
    renovated?: boolean;
    needsToBeRenovated?: boolean;
    neoClassical?: boolean;
    preserved?: boolean;
    incomplete?: boolean;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classified?: ClassifiedDto | undefined;

    constructor(data?: IClassifiedConstructionDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.classifiedConstructionID = _data["classifiedConstructionID"];
            this.pentHouse = _data["pentHouse"];
            this.newlyBuilt = _data["newlyBuilt"];
            this.renovated = _data["renovated"];
            this.needsToBeRenovated = _data["needsToBeRenovated"];
            this.neoClassical = _data["neoClassical"];
            this.preserved = _data["preserved"];
            this.incomplete = _data["incomplete"];
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
            this.isDeleted = _data["isDeleted"];
            this.classified = _data["classified"] ? ClassifiedDto.fromJS(_data["classified"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ClassifiedConstructionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClassifiedConstructionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classifiedConstructionID"] = this.classifiedConstructionID;
        data["pentHouse"] = this.pentHouse;
        data["newlyBuilt"] = this.newlyBuilt;
        data["renovated"] = this.renovated;
        data["needsToBeRenovated"] = this.needsToBeRenovated;
        data["neoClassical"] = this.neoClassical;
        data["preserved"] = this.preserved;
        data["incomplete"] = this.incomplete;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        data["isDeleted"] = this.isDeleted;
        data["classified"] = this.classified ? this.classified.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IClassifiedConstructionDto extends IAuditableEntity {
    classifiedConstructionID?: number;
    pentHouse?: boolean;
    newlyBuilt?: boolean;
    renovated?: boolean;
    needsToBeRenovated?: boolean;
    neoClassical?: boolean;
    preserved?: boolean;
    incomplete?: boolean;
    description?: string | undefined;
    isEnabled?: boolean;
    isDeleted?: boolean;
    classified?: ClassifiedDto | undefined;
}

export class SlApiResponseOfClassifiedConstructionDtoAndObject implements ISlApiResponseOfClassifiedConstructionDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: ClassifiedConstructionDto | undefined;
    metaData?: any | undefined;

    constructor(data?: ISlApiResponseOfClassifiedConstructionDtoAndObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(SlApiMessage.fromJS(item));
            }
            this.data = _data["data"] ? ClassifiedConstructionDto.fromJS(_data["data"]) : <any>undefined;
            this.metaData = _data["metaData"];
        }
    }

    static fromJS(data: any): SlApiResponseOfClassifiedConstructionDtoAndObject {
        data = typeof data === 'object' ? data : {};
        let result = new SlApiResponseOfClassifiedConstructionDtoAndObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["metaData"] = this.metaData;
        return data;
    }
}

export interface ISlApiResponseOfClassifiedConstructionDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: ClassifiedConstructionDto | undefined;
    metaData?: any | undefined;
}

export class SlApiResponseOfPaginatedListOfClassifiedPurposeDtoAndObject implements ISlApiResponseOfPaginatedListOfClassifiedPurposeDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: PaginatedListOfClassifiedPurposeDto | undefined;
    metaData?: any | undefined;

    constructor(data?: ISlApiResponseOfPaginatedListOfClassifiedPurposeDtoAndObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(SlApiMessage.fromJS(item));
            }
            this.data = _data["data"] ? PaginatedListOfClassifiedPurposeDto.fromJS(_data["data"]) : <any>undefined;
            this.metaData = _data["metaData"];
        }
    }

    static fromJS(data: any): SlApiResponseOfPaginatedListOfClassifiedPurposeDtoAndObject {
        data = typeof data === 'object' ? data : {};
        let result = new SlApiResponseOfPaginatedListOfClassifiedPurposeDtoAndObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["metaData"] = this.metaData;
        return data;
    }
}

export interface ISlApiResponseOfPaginatedListOfClassifiedPurposeDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: PaginatedListOfClassifiedPurposeDto | undefined;
    metaData?: any | undefined;
}

export class PaginatedListOfClassifiedPurposeDto implements IPaginatedListOfClassifiedPurposeDto {
    items?: ClassifiedPurposeDto[] | undefined;
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfClassifiedPurposeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ClassifiedPurposeDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfClassifiedPurposeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfClassifiedPurposeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfClassifiedPurposeDto {
    items?: ClassifiedPurposeDto[] | undefined;
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class SlApiResponseOfClassifiedPurposeDtoAndObject implements ISlApiResponseOfClassifiedPurposeDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: ClassifiedPurposeDto | undefined;
    metaData?: any | undefined;

    constructor(data?: ISlApiResponseOfClassifiedPurposeDtoAndObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(SlApiMessage.fromJS(item));
            }
            this.data = _data["data"] ? ClassifiedPurposeDto.fromJS(_data["data"]) : <any>undefined;
            this.metaData = _data["metaData"];
        }
    }

    static fromJS(data: any): SlApiResponseOfClassifiedPurposeDtoAndObject {
        data = typeof data === 'object' ? data : {};
        let result = new SlApiResponseOfClassifiedPurposeDtoAndObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["metaData"] = this.metaData;
        return data;
    }
}

export interface ISlApiResponseOfClassifiedPurposeDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: ClassifiedPurposeDto | undefined;
    metaData?: any | undefined;
}

export class SlApiResponseOfPaginatedListOfClassifiedTypeDtoAndObject implements ISlApiResponseOfPaginatedListOfClassifiedTypeDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: PaginatedListOfClassifiedTypeDto | undefined;
    metaData?: any | undefined;

    constructor(data?: ISlApiResponseOfPaginatedListOfClassifiedTypeDtoAndObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(SlApiMessage.fromJS(item));
            }
            this.data = _data["data"] ? PaginatedListOfClassifiedTypeDto.fromJS(_data["data"]) : <any>undefined;
            this.metaData = _data["metaData"];
        }
    }

    static fromJS(data: any): SlApiResponseOfPaginatedListOfClassifiedTypeDtoAndObject {
        data = typeof data === 'object' ? data : {};
        let result = new SlApiResponseOfPaginatedListOfClassifiedTypeDtoAndObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["metaData"] = this.metaData;
        return data;
    }
}

export interface ISlApiResponseOfPaginatedListOfClassifiedTypeDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: PaginatedListOfClassifiedTypeDto | undefined;
    metaData?: any | undefined;
}

export class PaginatedListOfClassifiedTypeDto implements IPaginatedListOfClassifiedTypeDto {
    items?: ClassifiedTypeDto[] | undefined;
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfClassifiedTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ClassifiedTypeDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfClassifiedTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfClassifiedTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfClassifiedTypeDto {
    items?: ClassifiedTypeDto[] | undefined;
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class SlApiResponseOfClassifiedTypeDtoAndObject implements ISlApiResponseOfClassifiedTypeDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: ClassifiedTypeDto | undefined;
    metaData?: any | undefined;

    constructor(data?: ISlApiResponseOfClassifiedTypeDtoAndObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(SlApiMessage.fromJS(item));
            }
            this.data = _data["data"] ? ClassifiedTypeDto.fromJS(_data["data"]) : <any>undefined;
            this.metaData = _data["metaData"];
        }
    }

    static fromJS(data: any): SlApiResponseOfClassifiedTypeDtoAndObject {
        data = typeof data === 'object' ? data : {};
        let result = new SlApiResponseOfClassifiedTypeDtoAndObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["metaData"] = this.metaData;
        return data;
    }
}

export interface ISlApiResponseOfClassifiedTypeDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: ClassifiedTypeDto | undefined;
    metaData?: any | undefined;
}

export class SlApiResponseOfPaginatedListOfEnergyClassDtoAndObject implements ISlApiResponseOfPaginatedListOfEnergyClassDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: PaginatedListOfEnergyClassDto | undefined;
    metaData?: any | undefined;

    constructor(data?: ISlApiResponseOfPaginatedListOfEnergyClassDtoAndObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(SlApiMessage.fromJS(item));
            }
            this.data = _data["data"] ? PaginatedListOfEnergyClassDto.fromJS(_data["data"]) : <any>undefined;
            this.metaData = _data["metaData"];
        }
    }

    static fromJS(data: any): SlApiResponseOfPaginatedListOfEnergyClassDtoAndObject {
        data = typeof data === 'object' ? data : {};
        let result = new SlApiResponseOfPaginatedListOfEnergyClassDtoAndObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["metaData"] = this.metaData;
        return data;
    }
}

export interface ISlApiResponseOfPaginatedListOfEnergyClassDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: PaginatedListOfEnergyClassDto | undefined;
    metaData?: any | undefined;
}

export class PaginatedListOfEnergyClassDto implements IPaginatedListOfEnergyClassDto {
    items?: EnergyClassDto[] | undefined;
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfEnergyClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EnergyClassDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfEnergyClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfEnergyClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfEnergyClassDto {
    items?: EnergyClassDto[] | undefined;
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class SlApiResponseOfEnergyClassDtoAndObject implements ISlApiResponseOfEnergyClassDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: EnergyClassDto | undefined;
    metaData?: any | undefined;

    constructor(data?: ISlApiResponseOfEnergyClassDtoAndObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(SlApiMessage.fromJS(item));
            }
            this.data = _data["data"] ? EnergyClassDto.fromJS(_data["data"]) : <any>undefined;
            this.metaData = _data["metaData"];
        }
    }

    static fromJS(data: any): SlApiResponseOfEnergyClassDtoAndObject {
        data = typeof data === 'object' ? data : {};
        let result = new SlApiResponseOfEnergyClassDtoAndObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["metaData"] = this.metaData;
        return data;
    }
}

export interface ISlApiResponseOfEnergyClassDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: EnergyClassDto | undefined;
    metaData?: any | undefined;
}

export class SlApiResponseOfPaginatedListOfExteriorFeatureDtoAndObject implements ISlApiResponseOfPaginatedListOfExteriorFeatureDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: PaginatedListOfExteriorFeatureDto | undefined;
    metaData?: any | undefined;

    constructor(data?: ISlApiResponseOfPaginatedListOfExteriorFeatureDtoAndObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(SlApiMessage.fromJS(item));
            }
            this.data = _data["data"] ? PaginatedListOfExteriorFeatureDto.fromJS(_data["data"]) : <any>undefined;
            this.metaData = _data["metaData"];
        }
    }

    static fromJS(data: any): SlApiResponseOfPaginatedListOfExteriorFeatureDtoAndObject {
        data = typeof data === 'object' ? data : {};
        let result = new SlApiResponseOfPaginatedListOfExteriorFeatureDtoAndObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["metaData"] = this.metaData;
        return data;
    }
}

export interface ISlApiResponseOfPaginatedListOfExteriorFeatureDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: PaginatedListOfExteriorFeatureDto | undefined;
    metaData?: any | undefined;
}

export class PaginatedListOfExteriorFeatureDto implements IPaginatedListOfExteriorFeatureDto {
    items?: ExteriorFeatureDto[] | undefined;
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfExteriorFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ExteriorFeatureDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfExteriorFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfExteriorFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfExteriorFeatureDto {
    items?: ExteriorFeatureDto[] | undefined;
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class SlApiResponseOfExteriorFeatureDtoAndObject implements ISlApiResponseOfExteriorFeatureDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: ExteriorFeatureDto | undefined;
    metaData?: any | undefined;

    constructor(data?: ISlApiResponseOfExteriorFeatureDtoAndObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(SlApiMessage.fromJS(item));
            }
            this.data = _data["data"] ? ExteriorFeatureDto.fromJS(_data["data"]) : <any>undefined;
            this.metaData = _data["metaData"];
        }
    }

    static fromJS(data: any): SlApiResponseOfExteriorFeatureDtoAndObject {
        data = typeof data === 'object' ? data : {};
        let result = new SlApiResponseOfExteriorFeatureDtoAndObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["metaData"] = this.metaData;
        return data;
    }
}

export interface ISlApiResponseOfExteriorFeatureDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: ExteriorFeatureDto | undefined;
    metaData?: any | undefined;
}

export class SlApiResponseOfPaginatedListOfFloorNoDtoAndObject implements ISlApiResponseOfPaginatedListOfFloorNoDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: PaginatedListOfFloorNoDto | undefined;
    metaData?: any | undefined;

    constructor(data?: ISlApiResponseOfPaginatedListOfFloorNoDtoAndObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(SlApiMessage.fromJS(item));
            }
            this.data = _data["data"] ? PaginatedListOfFloorNoDto.fromJS(_data["data"]) : <any>undefined;
            this.metaData = _data["metaData"];
        }
    }

    static fromJS(data: any): SlApiResponseOfPaginatedListOfFloorNoDtoAndObject {
        data = typeof data === 'object' ? data : {};
        let result = new SlApiResponseOfPaginatedListOfFloorNoDtoAndObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["metaData"] = this.metaData;
        return data;
    }
}

export interface ISlApiResponseOfPaginatedListOfFloorNoDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: PaginatedListOfFloorNoDto | undefined;
    metaData?: any | undefined;
}

export class PaginatedListOfFloorNoDto implements IPaginatedListOfFloorNoDto {
    items?: FloorNoDto[] | undefined;
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfFloorNoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FloorNoDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfFloorNoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfFloorNoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfFloorNoDto {
    items?: FloorNoDto[] | undefined;
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class SlApiResponseOfFloorNoDtoAndObject implements ISlApiResponseOfFloorNoDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: FloorNoDto | undefined;
    metaData?: any | undefined;

    constructor(data?: ISlApiResponseOfFloorNoDtoAndObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(SlApiMessage.fromJS(item));
            }
            this.data = _data["data"] ? FloorNoDto.fromJS(_data["data"]) : <any>undefined;
            this.metaData = _data["metaData"];
        }
    }

    static fromJS(data: any): SlApiResponseOfFloorNoDtoAndObject {
        data = typeof data === 'object' ? data : {};
        let result = new SlApiResponseOfFloorNoDtoAndObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["metaData"] = this.metaData;
        return data;
    }
}

export interface ISlApiResponseOfFloorNoDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: FloorNoDto | undefined;
    metaData?: any | undefined;
}

export class SlApiResponseOfPaginatedListOfFloorTypeDtoAndObject implements ISlApiResponseOfPaginatedListOfFloorTypeDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: PaginatedListOfFloorTypeDto | undefined;
    metaData?: any | undefined;

    constructor(data?: ISlApiResponseOfPaginatedListOfFloorTypeDtoAndObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(SlApiMessage.fromJS(item));
            }
            this.data = _data["data"] ? PaginatedListOfFloorTypeDto.fromJS(_data["data"]) : <any>undefined;
            this.metaData = _data["metaData"];
        }
    }

    static fromJS(data: any): SlApiResponseOfPaginatedListOfFloorTypeDtoAndObject {
        data = typeof data === 'object' ? data : {};
        let result = new SlApiResponseOfPaginatedListOfFloorTypeDtoAndObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["metaData"] = this.metaData;
        return data;
    }
}

export interface ISlApiResponseOfPaginatedListOfFloorTypeDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: PaginatedListOfFloorTypeDto | undefined;
    metaData?: any | undefined;
}

export class PaginatedListOfFloorTypeDto implements IPaginatedListOfFloorTypeDto {
    items?: FloorTypeDto[] | undefined;
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfFloorTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FloorTypeDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfFloorTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfFloorTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfFloorTypeDto {
    items?: FloorTypeDto[] | undefined;
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class SlApiResponseOfFloorTypeDtoAndObject implements ISlApiResponseOfFloorTypeDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: FloorTypeDto | undefined;
    metaData?: any | undefined;

    constructor(data?: ISlApiResponseOfFloorTypeDtoAndObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(SlApiMessage.fromJS(item));
            }
            this.data = _data["data"] ? FloorTypeDto.fromJS(_data["data"]) : <any>undefined;
            this.metaData = _data["metaData"];
        }
    }

    static fromJS(data: any): SlApiResponseOfFloorTypeDtoAndObject {
        data = typeof data === 'object' ? data : {};
        let result = new SlApiResponseOfFloorTypeDtoAndObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["metaData"] = this.metaData;
        return data;
    }
}

export interface ISlApiResponseOfFloorTypeDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: FloorTypeDto | undefined;
    metaData?: any | undefined;
}

export class SlApiResponseOfPaginatedListOfFrameTypeDtoAndObject implements ISlApiResponseOfPaginatedListOfFrameTypeDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: PaginatedListOfFrameTypeDto | undefined;
    metaData?: any | undefined;

    constructor(data?: ISlApiResponseOfPaginatedListOfFrameTypeDtoAndObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(SlApiMessage.fromJS(item));
            }
            this.data = _data["data"] ? PaginatedListOfFrameTypeDto.fromJS(_data["data"]) : <any>undefined;
            this.metaData = _data["metaData"];
        }
    }

    static fromJS(data: any): SlApiResponseOfPaginatedListOfFrameTypeDtoAndObject {
        data = typeof data === 'object' ? data : {};
        let result = new SlApiResponseOfPaginatedListOfFrameTypeDtoAndObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["metaData"] = this.metaData;
        return data;
    }
}

export interface ISlApiResponseOfPaginatedListOfFrameTypeDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: PaginatedListOfFrameTypeDto | undefined;
    metaData?: any | undefined;
}

export class PaginatedListOfFrameTypeDto implements IPaginatedListOfFrameTypeDto {
    items?: FrameTypeDto[] | undefined;
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfFrameTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FrameTypeDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfFrameTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfFrameTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfFrameTypeDto {
    items?: FrameTypeDto[] | undefined;
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class SlApiResponseOfFrameTypeDtoAndObject implements ISlApiResponseOfFrameTypeDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: FrameTypeDto | undefined;
    metaData?: any | undefined;

    constructor(data?: ISlApiResponseOfFrameTypeDtoAndObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(SlApiMessage.fromJS(item));
            }
            this.data = _data["data"] ? FrameTypeDto.fromJS(_data["data"]) : <any>undefined;
            this.metaData = _data["metaData"];
        }
    }

    static fromJS(data: any): SlApiResponseOfFrameTypeDtoAndObject {
        data = typeof data === 'object' ? data : {};
        let result = new SlApiResponseOfFrameTypeDtoAndObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["metaData"] = this.metaData;
        return data;
    }
}

export interface ISlApiResponseOfFrameTypeDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: FrameTypeDto | undefined;
    metaData?: any | undefined;
}

export class SlApiResponseOfPaginatedListOfGoogleMapPlaceDtoAndObject implements ISlApiResponseOfPaginatedListOfGoogleMapPlaceDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: PaginatedListOfGoogleMapPlaceDto | undefined;
    metaData?: any | undefined;

    constructor(data?: ISlApiResponseOfPaginatedListOfGoogleMapPlaceDtoAndObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(SlApiMessage.fromJS(item));
            }
            this.data = _data["data"] ? PaginatedListOfGoogleMapPlaceDto.fromJS(_data["data"]) : <any>undefined;
            this.metaData = _data["metaData"];
        }
    }

    static fromJS(data: any): SlApiResponseOfPaginatedListOfGoogleMapPlaceDtoAndObject {
        data = typeof data === 'object' ? data : {};
        let result = new SlApiResponseOfPaginatedListOfGoogleMapPlaceDtoAndObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["metaData"] = this.metaData;
        return data;
    }
}

export interface ISlApiResponseOfPaginatedListOfGoogleMapPlaceDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: PaginatedListOfGoogleMapPlaceDto | undefined;
    metaData?: any | undefined;
}

export class PaginatedListOfGoogleMapPlaceDto implements IPaginatedListOfGoogleMapPlaceDto {
    items?: GoogleMapPlaceDto[] | undefined;
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfGoogleMapPlaceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GoogleMapPlaceDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfGoogleMapPlaceDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfGoogleMapPlaceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfGoogleMapPlaceDto {
    items?: GoogleMapPlaceDto[] | undefined;
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class SlApiResponseOfGoogleMapPlaceDtoAndObject implements ISlApiResponseOfGoogleMapPlaceDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: GoogleMapPlaceDto | undefined;
    metaData?: any | undefined;

    constructor(data?: ISlApiResponseOfGoogleMapPlaceDtoAndObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(SlApiMessage.fromJS(item));
            }
            this.data = _data["data"] ? GoogleMapPlaceDto.fromJS(_data["data"]) : <any>undefined;
            this.metaData = _data["metaData"];
        }
    }

    static fromJS(data: any): SlApiResponseOfGoogleMapPlaceDtoAndObject {
        data = typeof data === 'object' ? data : {};
        let result = new SlApiResponseOfGoogleMapPlaceDtoAndObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["metaData"] = this.metaData;
        return data;
    }
}

export interface ISlApiResponseOfGoogleMapPlaceDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: GoogleMapPlaceDto | undefined;
    metaData?: any | undefined;
}

export class SlApiResponseOfPaginatedListOfHeatingSystemDtoAndObject implements ISlApiResponseOfPaginatedListOfHeatingSystemDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: PaginatedListOfHeatingSystemDto | undefined;
    metaData?: any | undefined;

    constructor(data?: ISlApiResponseOfPaginatedListOfHeatingSystemDtoAndObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(SlApiMessage.fromJS(item));
            }
            this.data = _data["data"] ? PaginatedListOfHeatingSystemDto.fromJS(_data["data"]) : <any>undefined;
            this.metaData = _data["metaData"];
        }
    }

    static fromJS(data: any): SlApiResponseOfPaginatedListOfHeatingSystemDtoAndObject {
        data = typeof data === 'object' ? data : {};
        let result = new SlApiResponseOfPaginatedListOfHeatingSystemDtoAndObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["metaData"] = this.metaData;
        return data;
    }
}

export interface ISlApiResponseOfPaginatedListOfHeatingSystemDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: PaginatedListOfHeatingSystemDto | undefined;
    metaData?: any | undefined;
}

export class PaginatedListOfHeatingSystemDto implements IPaginatedListOfHeatingSystemDto {
    items?: HeatingSystemDto[] | undefined;
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfHeatingSystemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(HeatingSystemDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfHeatingSystemDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfHeatingSystemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfHeatingSystemDto {
    items?: HeatingSystemDto[] | undefined;
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class SlApiResponseOfHeatingSystemDtoAndObject implements ISlApiResponseOfHeatingSystemDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: HeatingSystemDto | undefined;
    metaData?: any | undefined;

    constructor(data?: ISlApiResponseOfHeatingSystemDtoAndObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(SlApiMessage.fromJS(item));
            }
            this.data = _data["data"] ? HeatingSystemDto.fromJS(_data["data"]) : <any>undefined;
            this.metaData = _data["metaData"];
        }
    }

    static fromJS(data: any): SlApiResponseOfHeatingSystemDtoAndObject {
        data = typeof data === 'object' ? data : {};
        let result = new SlApiResponseOfHeatingSystemDtoAndObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["metaData"] = this.metaData;
        return data;
    }
}

export interface ISlApiResponseOfHeatingSystemDtoAndObject {
    isError?: boolean;
    messages?: SlApiMessage[] | undefined;
    data?: HeatingSystemDto | undefined;
    metaData?: any | undefined;
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}